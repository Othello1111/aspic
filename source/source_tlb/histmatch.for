C
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C
C                     ***********************
C                     *                     *
C                     * Program   HISTMATCH *
C                     *                     *
C                     ***********************
C
C
C
C          CALLING SEQUENCE:-
C               HISTMATCH   [  hist  ]
C
C
C          FUNCTION:-
C               It applies a non-linear transformation to the  data  values
C               in an image so that the histogram of the output image has a
C               prescribed form. This may be the same as a histogram  (from
C               another image?) stored in a 1-d Starlink image, or simply a
C               histogram with equal samples in each bin.
C
C
C          USE:-
C               It  may  be  used  to  enhance  contrast,  most  often   by
C               "histogram equalization", but may also be used to match two
C               images, for example if they are to be  compared  or  fitted
C               together.
C
C
C
C         USER PARAMETERS:-
C
C         INPUT                               The input Starlink frame.
C
C         OUTPUT                              The output Starlink frame.
C
C         INLIMS            Range in INPUT    Range  of  values  to  be  used  i
C                                             computing the histogram of INPUT.
C
C         NUMBIN             same as INLIMS   The number  of  bins  in  the
C                                             histogram.
C
C
C         NORMALLY DEFAULTED PARAMETERS:-
C
C         HIST                                If present it is taken as   a
C                                             1-d Starlink image containing
C                                             a  model  of   the   required
C                                             output  histogram.  If absent
C                                             the   output   histogram   is
C                                             defined  as  being  constant,
C                                             giving "equalization".
C
C
C
C
C
C
C
C         W F Lupton               RGO                             7-JAN-82
C
C
C--------------------------------------------------------------------------



	PROGRAM HISTMATCH
C
C +	STARLINK ENVIRONMENT PROGRAM ****HISTMATCH****
C
C VERSION #3
C
C WRITTEN BY W F LUPTON RGO JANUARY 1981
C
C PROGRAM TO PERFORM HISTOGRAM MANIPULATION ON AN IMAGE. THE
C DESIRED OUTPUT HISTOGRAM CAN EITHER BE:-
C 	1	CONSTANT ('EQUALISATION')
C 	2	INPUT AS A STARLINK 1D IMAGE
C
C PARAMETERS:-
C 	INPUT	INPUT FRAME
C 	OUTPUT	OUTPUT FRAME
C 	HIST	HISTOGRAM INPUT FRAME (EQUALISE IF NULL)
C 	INLIMS	RANGE OF VALUES TAKEN IN INPUT FRAME
C 	NUMBIN	NO OF BINS TO USE IN CALCULATION
C
C    WFL/RGO (SIMPLIFIED OCT 1981 PLUS MINOR MODS)
C
      INCLUDE 'INTERIM(ERRPAR)'
      INCLUDE 'INTERIM(FMTPAR)'
	INTEGER AXIS(99),NAXIS,IPNTR,ERROR,WPNTR(5),HPNTR,HAXIS,HLENG,
	1	OPNTR,ISIZE
	REAL INLIMS(2)
	CHARACTER C*1
	LOGICAL EQUAL
C
C FIRST OF ALL, OBTAIN INPUT AND OUTPUT FRAMES
C
	CALL RDIMAG('INPUT',FMT_R,99,AXIS,NAXIS,IPNTR,ERROR)
	IF (ERROR.NE.ERR_NORMAL) THEN
		CALL WRERR ('BADINP')
		GOTO 999
	ENDIF
	CALL WRIMAG('OUTPUT',FMT_R,AXIS,NAXIS,OPNTR,ERROR)
	IF (ERROR.NE.ERR_NORMAL) THEN
		CALL WRERR ('BADOUT')
		GOTO 999
	ENDIF
C
C CALCULATE SIZE IN ISIZE
C
	ISIZE=1
	DO I=1,NAXIS
		ISIZE=ISIZE*AXIS(I)
	ENDDO
C
C DECIDE HOW HISTOGRAM OF OUTPUT IS SPECIFIED
C
	CALL RDIMAG('HIST',FMT_SL,1,HLENG,HAXIS,HPNTR,ERROR)
	IF (ERROR.EQ.ERR_PARNUL) THEN
		HLENG=2
		CALL GETDYN('HIST',FMT_SL,HLENG,HPNTR,ERROR)
		IF (ERROR.NE.ERR_NORMAL) THEN
			CALL WRERR('GETWORK')
			GOTO 999
		ENDIF
		CALL ICONST(%VAL(HPNTR),HLENG,1)
	ELSE IF (HAXIS.NE.1) THEN
		CALL WRERR ('BADHIST')
		GOTO 999
	ENDIF
C
C INLIMS
C
	CALL ASP_RANGE ('INPUT',%VAL(IPNTR),ISIZE,INLIMS(1),INLIMS(2),ERROR)
	CALL RDKEYR('INLIMS',.TRUE.,2,INLIMS,I,ERROR)
	IF (INLIMS(1).GE.INLIMS(2)) THEN
		CALL WRERR ('BADINLIM')
		GOTO 999
	ENDIF
C
C NUMBIN
C
	NUMBIN=MIN(32767.0,INLIMS(2)-INLIMS(1))
	CALL RDKEYI('NUMBIN',.TRUE.,1,NUMBIN,I,ERROR)
	IF (NUMBIN.LE.0) THEN
		CALL WRERR ('BADNUM')
		GOTO 999
	ENDIF
C
C NOW OBTAIN DYNAMIC STORAGE FOR WORKSPACE
C
	DO I=1,5
		WRITE (C,'(I1)') I
		CALL GETDYN('WORK'//C,FMT_SL,NUMBIN,WPNTR(I),ERROR)
		IF (ERROR.NE.ERR_NORMAL) THEN
			CALL WRERR('GETWORK')
			GOTO 999
		ENDIF
	ENDDO
C
C USE SUBROUTINE HISTMATCH2 TO DO ALL THE WORK
C
	CALL HISTMATCH2(%VAL(IPNTR),ISIZE,%VAL(HPNTR),HLENG,
	1	%VAL(WPNTR(1)),%VAL(WPNTR(2)),%VAL(WPNTR(3)),%VAL(WPNTR(4)),
	1	%VAL(WPNTR(5)),NUMBIN,INLIMS,%VAL(OPNTR))
C
C FREE DATA AND STOP
C
999	END
C
	SUBROUTINE HISTMATCH2(INPUT,ISIZE,OUTHIST,NHIST,BINS,
	1	SINS,BILL,BEN,MAP,NUMBIN,INLIMS,OUTPUT)
C
C ROUTINE TO PERFORM THE TASK OF HISTOGRAM MANIPULATION
C
C WRITTEN BY W F LUPTON RGO NOVEMBER 1980
C
C ARGUMENTS:-
C NAME	TYPE	DESCRIPTION
C INPUT	RA	INPUT IMAGE ARRAY
C ISIZE	I	SIZE OF INPUT
C OUTHIST	IA	IDEAL OUTPUT HISTOGRAM
C NHIST	I	LENGTH OF OUTHIST
C BINS	IA	ARRAY CONTAINING DATA BINNED FROM INPUT
C SINS	IA	ARRAY TO CONTAIN IDEAL OUTPUT HISTOGRAM
C 		DIFFERS FROM OUTHIST IN THAT SINS IS OF THE
C 		SAME LENGTH AS BINS WHEREAS OUTHIST MAY BE OF
C 		ANY LENGTH.
C BILL	IA	WORKSPACE FOR ROUTINE HTRANS
C BEN	IA	    "      "     "      "
C MAP	IA	MAPPING OF GREY LEVELS INPUT -> OUTPUT
C NUMBIN	I	LENGTH OF THE ABOVE FIVE ARRAYS
C INLIMS	RA	ARRAY: LOW AND HIGH LIMITS IN INPUT
C
C OUTPUT	RA	OUTPUT IMAGE ARRAY (SAME ISIZE AS INPUT)
C
	INTEGER OUTHIST(0:NHIST-1),BINS(0:NUMBIN-1),SINS(0:NUMBIN-1),
	1	BILL(0:NUMBIN-1),BEN(0:NUMBIN-1),MAP(0:NUMBIN-1),
	1	ERROR,ISIZE
	REAL INPUT(ISIZE),OUTPUT(ISIZE),INLIMS(2)
	NUMM1=NUMBIN-1
	NHIS1=NHIST-1
C
C USE ASP_HGRAM TO CALCULATE HISTOGRAM
C
	CALL ASP_HGRAM ('INPUT',INPUT,ISIZE,INLIMS(1),INLIMS(2),
	1	NUMBIN,BINS,ERROR)
C
C SET UP, IN SINS, IDEAL OUTPUT HIST OF SAME SIZE AS BINS
C
	I=NUMM1/2
	DO J=0,NUMM1
		SINS(J)=OUTHIST((J*NHIS1+I)/NUMM1)
	ENDDO
C
C NOW CALL HTRANS TO DO THE TRANSFORMATION
C
	CALL HTRANS(BINS,SINS,BILL,BEN,0,NUMM1,MAP)
C
C TRANSFORMATION HAS BEEN COMPLETED SATISFACTORILY.
C NOW USE IT TO UPDATE INPUT INTO OUTPUT
C
	SCALE=NUMM1/(INLIMS(2)-INLIMS(1))
	SCALER=1.0/SCALE
	DO I=1,ISIZE
		K=SCALE*(INPUT(I)-INLIMS(1))
		IF (K.LT.0) THEN
			OUTPUT(I)=INLIMS(1)
		ELSE IF (K.LE.NUMM1) THEN
			OUTPUT(I)=INLIMS(1)+SCALER*MAP(K)
		ELSE
			OUTPUT(I)=INLIMS(2)
		ENDIF
	ENDDO
   	END
C
	SUBROUTINE HTRANS(HOLD,HNEW,WOLD,WNEW,IMIN,IMAX,LMAP)
C
C ROUTINE TO CONVERT HISTOGRAM IN "HOLD" INTO THAT IN "HNEW"
C AS NEARLY AS POSSIBLE WHILST REQUIRING THAT HISTOGRAM BARS
C NEVER BE SPLIT UP (ALTHOUGH SEVERAL MAY BE COMBINED)
C
C THE RESULTING HISTOGRAM IS RETURNED TO "HOLD". NOTE THAT
C NEITHER HISTOGRAM NEED IN ANY WAY BE NORMALISED.
C
C ARGS:	HOLD	INPUT/OUTPUT HISTOGRAM
C 	HNEW	IDEAL OUTPUT HISTOGRAM
C 	WOLD	WORKSPACE ARRAY (CUMULATIVE HOLD)
C 	WNEW		"	(	"   HNEW)
C 	IMIN	MIN ELT OF HOLD
C 	IMAX	MAX ELT OF HOLD
C 	LMAP	MAPPING FROM OLD LEVELS TO NEW ONES
C
C W.F.LUPTON AUGUST 1980
C
	INTEGER HOLD(IMIN:IMAX),HNEW(IMIN:IMAX)
	INTEGER WNEW(IMIN:IMAX),WOLD(IMIN:IMAX)
	INTEGER LMAP(IMIN:IMAX),OLD,NEW,DIFF,LAST
C
C EVALUATE CUMULATIVE DISTRIBUTION OF HOLD AND HNEW IN WOLD
C AND WNEW
C
	WOLD(IMIN)=HOLD(IMIN)
	WNEW(IMIN)=HNEW(IMIN)
	DO I=IMIN+1,IMAX
		WOLD(I)=WOLD(I-1)+HOLD(I)
		WNEW(I)=WNEW(I-1)+HNEW(I)
	ENDDO
C
C WE HAVEN'T FORCED HNEW TO BE NORMALISED (WRT HOLD), SO
C RESCALE HNEW AND WNEW BY MULTIPLYING BY WOLD(IMAX)/WNEW(IMAX)
C USING REAL ARITHMETIC
C
	IF (WNEW(IMAX).EQ.0) THEN
		CALL WRUSER('OUTPUT HISTOGRAM EMPTY - NOTHING DONE',ERROR)
	ENDIF
	FACTOR=REAL(WOLD(IMAX))/REAL(WNEW(IMAX))
	IF (ABS(FACTOR-1.0).GT.1E-3) THEN
		DO I=IMIN,IMAX
			HNEW(I)=REAL(HNEW(I))*FACTOR
			WNEW(I)=REAL(WNEW(I))*FACTOR
		ENDDO
		WNEW(IMAX)=WOLD(IMAX)
	ENDIF
C
C NOTE THAT HNEW, WNEW ARE STILL INTEGERS, BUT ALL THE
C ARITHMETIC WAS REAL!!
C
C CLEAR HOLD TO ZEROES
C
	DO I=IMIN,IMAX
		HOLD(I)=0
	ENDDO
C
C INITIALISE COUNTERS
C
	OLD=IMIN
	NEW=IMIN
	LAST=0
	WMAX=WNEW(IMAX)
	DO WHILE (OLD.LE.IMAX.AND.NEW.LE.IMAX)
C
C CHECK WHETHER NEED TO INCREMENT NEW
C
		IF (WOLD(OLD).LE.WNEW(NEW)) THEN
			DIFF=WOLD(OLD)-LAST
			LAST=WOLD(OLD)
C
C DECIDE WHETHER TO ALLOCATE PIXELS TO 'NEW' OR 'NEW-1'
C
			IF (NEW.EQ.IMIN) THEN
				W0=0
				H0=0
			ELSE
				W0=WNEW(NEW-1)
				H0=HNEW(NEW-1)
			ENDIF
			W1=WNEW(NEW)
			H1=HNEW(NEW)
			F=(W0+W1+(W1-W0)*(H1-H0)/WMAX)/2.0+0.5
			IF (WOLD(OLD).LE.INT(F).AND.NEW.NE.IMIN) THEN
				I=NEW-1
			ELSE
				I=NEW
			ENDIF
			HOLD(I)=HOLD(I)+DIFF
			LMAP(OLD)=I
			OLD=OLD+1
		ELSE
			NEW=NEW+1
		ENDIF
	ENDDO
	END
C
	SUBROUTINE ICONST(ARRAY,ISIZE,VAL)
C
C ROUTINE TO SET AN INTEGER ARRAY TO A CONSTANT VALUE
C
	INTEGER ARRAY(ISIZE),VAL
	DO I=1,ISIZE
		ARRAY(I)=VAL
	ENDDO
	END
