	PROGRAM ABLOCK
C
C+	PROGRAM ABLOCK
C
C	PROGRAM TO PUT BLOCKS COVERING THE ENTIRE LOOKUP TABLE
C	RANGE UP ON THE ARGS SCREEN
C
C	PARAMETERS
C		XC	POSITION OF CENTRE OF BLOCKS
C		YC
C		L	LENGTH (IN PIXELS) OF THE BLOCKS
C
C               THE DEFAULTS FOR THE PARAMETERS ARE SUCH THAT THE
C               BLOCKS WILL COVER THE COMPLETE LENGTH OF THE IMAGE
C		AND WILL BE  PLACED JUST ABOVE THE LAST DRAWN IMAGE
C		PROVIDED SPACE IS AVAILABLE; OTHERWISE IT WILL
C		MASK PART OF THE IMAGE.
C
C



C	WFL RGO FEB 1981 MODIF JULY 1981 TO ACCESS ARGS DATABASE
C
C	WFL MOD SEP 1981 TO UPDATE ARGS DATABASE ALSO (IMAGE TYPE 'OTHE')
C	MINOR MOD CHANGING DEFAULT YC BY KFH 11/4/83
C
	IMPLICIT INTEGER (A-Z)
      INCLUDE 'INTERIM(ERRPAR)'
      INCLUDE 'INTERIM(FMTPAR)'
	PARAMETER (MINLEN=16,MINHGT=MINLEN/16)
C
C	READ XYCENT (TRY AND READ POS OF CURRENT IMAGE TO SET DEFAULTS)
C
	CALL ARGS_RDIM(ICX,ICY,ISX,ISY,I,I,STATUS)
	IF (STATUS.EQ.0) THEN
		DXC=MAX(MIN(ICX,512-MINLEN/2),MINLEN/2)
		DYC=MAX(MIN(ICY+ISY/2+ISY/32+1,512-MINHGT/2),MINHGT/2)
		DL=MAX(MINLEN,MIN(ISX,2*MIN(DXC,512-DXC)))
	ELSE
		DXC=256
		DYC=496
		DL=512
	ENDIF
10	XC=DXC
	YC=DYC
	CALL RDKEYI('XC',.TRUE.,1,XC,I,STATUS)
	CALL RDKEYI('YC',.TRUE.,1,YC,I,STATUS2)
	STATUS = MAX(STATUS,STATUS2)
	IF (STATUS.NE.ERR_NORMAL.AND.STATUS.NE.ERR_PARNUL) THEN
		CALL CNPAR('XC',STATUS)
		CALL CNPAR('YC',STATUS)
		GOTO 10
	ENDIF
	IF (XC.LT.MINLEN/2.OR.XC.GT.512-MINLEN/2.OR.
     +	    YC.LT.MINHGT/2.OR.YC.GT.512-MINHGT/2) THEN
		CALL WRUSER('EITHER X OR Y OUT OF RANGE',STATUS)
		CALL CNPAR('XC',STATUS)
		CALL CNPAR('YC',STATUS)
		GOTO 10
	ENDIF
C
C	NOW READ L
C
20	L = DL
	CALL RDKEYI('L',.TRUE.,1,L,I,STATUS)
	IF (STATUS.NE.ERR_NORMAL.AND.STATUS.NE.ERR_PARNUL) THEN
		CALL CNPAR('L',STATUS)
		GOTO 20
	ENDIF
	IF (L.LT.MINLEN.OR.L.GT.2*MIN(XC,512-XC)) THEN
		CALL WRUSER('L OUT OF RANGE',STATUS)
		CALL CNPAR('L',STATUS)
		GOTO 20
	ENDIF
C
C	CALL ABLOC2 TO DO THE WORK AND UPDATE THE ARGS DATABASE
C
	CALL ABLOC2(XC,YC,L)
	CALL ABLOC3(XC,YC,L,STATUS)
	IF (STATUS.NE.0) THEN
		CALL WRUSER('COULDN''T UPDATE ARGS DATABASE',STATUS)
	ENDIF
	CALL EXIT
	END
C
	SUBROUTINE ABLOC2(X,Y,L)
C
	INTEGER X,Y,L,XL,YL,XR,YR
	XL=MAX(X-L/2,0)
	YL=MAX(Y-L/32,0)
	XR=MIN(XL+L-1,511)
	YR=MIN(YL+L/16-1,511)
C
C	GET ARGS
C
	CALL SRINIT(0,.FALSE.,STATUS)
	IF (STATUS.NE.0) THEN
		CALL WRUSER('NO ARGS',STATUS)
		GOTO 999
	ENDIF
C
C	AND DISPLAY BLOCKS
C
	TABVAL=0.0
	DELTA=255.0/REAL(L-1)
	DO I=XL,XR
		CALL SRBLOC(I,YL,I,YR,INT(TABVAL))
		TABVAL=TABVAL+DELTA
	ENDDO
C
C	AND RETURN
C
999	RETURN
	END
C
	SUBROUTINE ABLOC3(X,Y,XS,STATUS)
C
C	UPDATE ARGS DATABASE (V SIM TO ARGS_WRIM BUT IMAGE TYPE IS 'OTHE')
C
*+  Parameter definitions for args database retrieval suite

*   nos of standard, user and derived parameters and offsets to
*   starts of user and derived ones (also max no of values in a
*   derived parameter)
      integer NSTPAR,NUSPAR,NDVPAR,STPARB,USPARB,DVPARB,MAXPAR
      parameter (NSTPAR=18,NUSPAR=5,NDVPAR=4)
      parameter (STPARB=0,USPARB=NSTPAR,DVPARB=NSTPAR+NUSPAR)
      parameter (MAXPAR=6)

*   no of image types
      integer NTYPES
      parameter (NTYPES=3)

*   lengths of items in data record (and maximum length)
      integer TYPLEN,INTLEN,FLTLEN,LABLEN,UNILEN,PARLEN,USVLEN,MAXLEN
      parameter (TYPLEN=4,INTLEN=11,FLTLEN=15,LABLEN=8,UNILEN=8,
     :    PARLEN=8,USVLEN=80)
      parameter (MAXLEN=MAX(TYPLEN,INTLEN,FLTLEN,LABLEN,PARLEN,USVLEN))

*   file unit no, record length, max no of records and undefined integer
      integer DBCHAN,RECLEN,MAXREC,IUNDEF
      parameter (DBCHAN=42,IUNDEF=-1)
      parameter (RECLEN=TYPLEN+7*INTLEN+6*FLTLEN+2*LABLEN+2*UNILEN+
     :    NUSPAR*(PARLEN+USVLEN),MAXREC=RECLEN/INTLEN-1)

*   offsets to fields in data record
      integer OTYP,OACENX,OACENY,OASIZX,OASIZY,OPSIZX,OPSIZY,
     :    OPTOU1,OPTOU2,OPTOU3,OPTOU4,OPTOU5,OPTOU6,OLABX,OLABY,
     :    OUNITX,OUNITY,ONUSP,OUSP1,OUSV1,OUSV2,OUSV3,OUSV4,OUSV5
      parameter (OTYP=1,OACENX=OTYP+TYPLEN,OACENY=OACENX+INTLEN,
     :    OASIZX=OACENY+INTLEN,OASIZY=OASIZX+INTLEN,OPSIZX=OASIZY+
     :    INTLEN,OPSIZY=OPSIZX+INTLEN,OPTOU1=OPSIZY+INTLEN,OPTOU2=
     :    OPTOU1+FLTLEN,OPTOU3=OPTOU2+FLTLEN,OPTOU4=OPTOU3+FLTLEN,
     :    OPTOU5=OPTOU4+FLTLEN,OPTOU6=OPTOU5+FLTLEN,OLABX=OPTOU6+FLTLEN,
     :    OLABY=OLABX+LABLEN,OUNITX=OLABY+LABLEN,OUNITY=OUNITX+UNILEN,
     :    ONUSP=OUNITY+LABLEN,OUSP1=ONUSP+INTLEN,OUSV1=OUSP1+PARLEN,
     :    OUSV2=OUSV1+USVLEN+PARLEN,OUSV3=OUSV2+USVLEN+PARLEN,
     :    OUSV4=OUSV3+USVLEN+PARLEN,OUSV5=OUSV4+USVLEN+PARLEN)

*   array of offsets
      integer offset(DVPARB)
      data offset/OTYP,OACENX,OACENY,OASIZX,OASIZY,OPSIZX,OPSIZY,
     :    OPTOU1,OPTOU2,OPTOU3,OPTOU4,OPTOU5,OPTOU6,OLABX,OLABY,
     :    OUNITX,OUNITY,ONUSP,OUSV1,OUSV2,OUSV3,OUSV4,OUSV5/

*   array of lengths
      integer length(DVPARB)
      data length/TYPLEN,6*INTLEN,6*FLTLEN,2*LABLEN,2*UNILEN,INTLEN,
     :    5*USVLEN/
*   Logical name for current ARGS
      character ALGNAM*(*)
      parameter (ALGNAM='ARGS_DEVICE')
	INTEGER X,Y,XS,YS,STATUS,IDMAX,TSTAT
	YS=XS/16
	CALL ARGS_DOPDB(ALGNAM,STATUS)
	IF (STATUS.EQ.0) THEN
		CALL ARGS_QIDMX(IDMAX)
		CALL ARGS_TDB7P(IDMAX+1,'OTHE',X,Y,XS,YS,XS,YS,STATUS)
		IF (STATUS.EQ.0) THEN
			CALL ARGS_TIDY(IDMAX+1,STATUS)
		ENDIF
	ENDIF
	CALL ARGS_CLDB(TSTAT)
	RETURN
	END
