C+
C
C      STARLINK ENVIRONMENT PROGRAM      *** PACK ***
C
C      WRITTEN BY K F HARTLEY AT RGO ON 23/1/81
C
C      VERSION #3
C
C      THIS PROGRAM IS DESIGNED TO PACK AN IMAGE DOWN TO THE
C      SMALLEST POSSIBLE SPACE FOR TRANSMISSION OVER THE NETWORK
C
C      THE RESULTING FRAME CAN BE UNPACKED BY THE ROUTINE "UNPACK"
C
C      THE INPUT FRAME (INPUT) SHOULD HAVE BEEN SCALED TO VALUES
C      FROM 0 TO 1 OR 0 TO 3 BY THE ROUTINE "CONFLEV"
C      (OR BY DIVISION!)
C      IF IT HAS NOT BEEN SCALED BEFORE , IT IS NOW!!!
C      (MAKING IT VERSION #3)
C
C      THE OUTPUT FRAME (OUTPUT) IS OF TYPE I*2
C
C      THERE ARE NO OTHER PARAMETERS
C
C-
      INTEGER*4 PIN,POUT,AXIN(3),AXOU(3),STATUS
      INTEGER*4 PUSE,PTEMP
C
C      FIRST GET THE INPUT FRAME
C
      CALL RDIMAG('INPUT',102,3,AXIN,I,PIN,STATUS)
      IF (STATUS.NE.0.OR.I.LE.0.OR.I.GT.3) THEN
         CALL WRERR('HELLIN',STATUS)
         CALL FRDATA(' ',STATUS)
         CALL EXIT
      END IF
C
C      NOW WORK OUT THE TOTAL NUMBER OF PIXELS
C
      NTOT=1
      DO 10 K=1,I
         NTOT=NTOT*AXIN(K)
   10 CONTINUE
C
C      ENSURE THAT INSIGNIFICANT DIMENSIONS ARE SET TO ZERO
C
      IF (I.LT.3) THEN
         DO 20 K=I+1,3
           AXIN(K)=0
   20    CONTINUE
      END IF
C
C      NOW CHECK THAT DATA IS SCALED TO 0-1 OR 0-3
C
      CALL CHECKIN(%VAL(PIN),NTOT,ISCALE)
C
C      ISCALE GIVES RESULT 1 IF 0 TO 1
C                          2 IF 0 TO 3
C                          0 OTHERWISE
C                          IF ZERO WE SCALE IT NOW
C
      IF (ISCALE.EQ.0) THEN
         CALL WRERR('HELL',STATUS)
         CALL GETDYN('WORK',104,NTOT,PTEMP,STATUS)
         CALL DIVIDE(%VAL(PTEMP),%VAL(PIN),NTOT)
         PUSE=PTEMP
         ISCALE=2
      ELSE
         PUSE=PIN
      END IF
C
C      ISCALE CAN NOW BE USED TO FIND OUT HOW MANY OUTPUT PIXELS
C      ARE NEEDED ... (16/ISCALE) INPUT SAMPLES GO TO 1 OUTPUT SAMPLE
C
      NOUT=NTOT*ISCALE/16+1
C
C      NOW GET OUTPUT FRAME
C
      CALL WRIMAG('OUTPUT',302,NOUT,1,POUT,STATUS)
      IF (STATUS.NE.0) THEN
         CALL WRERR('HELLO',STATUS)
         CALL FRDATA(' ',STATUS)
         CALL EXIT
      END IF
C
C      NOW DO THE WORK
C
      CALL PACK(%VAL(PUSE),NTOT,%VAL(POUT),NOUT,ISCALE)
C
C      NOW STORE ENOUGH INFORMATION TO ALLOW UNPACKING
C
      CALL STORE (%VAL(POUT),NOUT,AXIN,ISCALE)
C
C      NOW TIDY UP AND GO HOME
C
      CALL FRDATA(' ',STATUS)
      CALL EXIT
      END
      SUBROUTINE CHECKIN(IN,N,ISC)
C
C      TAKES A 1D ARRAY AND CHECKS THAT (1) MIN IS ZERO
C                                       (2) MAX IS 1 OR 3
C
C      IF TRUE ISC IS SET TO 1 OR 2 , OTHERWISE IT IS SET TO 0
C
      INTEGER*2 IN(N)
      MIN=IN(1)
      MAX=IN(1)
      DO 100 I=1,N
         IF (IN(I).GT.MAX) MAX=IN(I)
         IF (IN(I).LT.MIN) MIN=IN(I)
  100 CONTINUE
      IF (MIN.EQ.0.AND.MAX.EQ.1) THEN
         ISC=1
      ELSE IF (MIN.EQ.0.AND.MAX.EQ.3) THEN
         ISC=2
      ELSE
         ISC=0
      END IF
C
C      ISC SHOULD NOW HAVE THE CORRECT VALUE   ...   SO RETURN
C
      RETURN
      END
      SUBROUTINE PACK(IN,N,OUT,M,ISC)
C
C     THE DATA IN IN(N) ARE IN THE RANGE 0 TO 1 OR 4
C     THEY ARE PACKED INTO OUT(M) AS TIGHTLY AS POSSIBLE
C
      INTEGER*2 IN(N),OUT(M),ISH
C
C      ICOUNT IS THE NUMBER OF VALUES TO BE PACKED INTO EACH
C      ELEMENT OF OUT ... IT IS DERIVED FROM ISC WHICH
C      HAS VALUE OF 1 OR 2
C
      ICOUNT=16/ISC
C
C      FIRST ZEROIZE THE OUTPUT ARRAY
C
      DO 100 I=1,M
         OUT(I)=0
  100 CONTINUE
C
C      NOW SET UP ICO AS A COUNT(-DOWN) VARIABLE
C
      ICO=ICOUNT-1
C
C      KOUT STEPS THROUGH THE OUTPUT ARRAY AS EACH ELEMENT IS FILLED
C
      KOUT=1
C
C      NOW LOOP THROUGH THE INPUT PIXELS
C
      DO 200 I=1,N
C
C      ISH IS THE NUMBER OF BITS TO SHIFT THE INPUT VALUE
C
         ISH=ICO*ISC
         IDAT=ISHFT(IN(I),ISH)
         OUT(KOUT)=OUT(KOUT)+IDAT
         ICO=ICO-1
C
C      IF ICO IS NEGATIVE WE ARE READY TO START ON THE NEXT
C      OUTPUT ELEMENT
C
         IF (ICO.LT.0) THEN
            ICO=ICOUNT-1
            KOUT=KOUT+1
         END IF
  200 CONTINUE
C
C      THE OUTPUT ARRAY SHOULD NOW BE FULL
C
      RETURN
      END
      SUBROUTINE STORE (OUT,N,DIMES,ISC)
C
C     OVERWRITES THE FIRST FEW ELEMENTS OF THE OUTPUT ARRAY
C      WITH THE SCALING AND DIMENSIONS OF THE ORIGINAL INPUT ARRAY
C
      INTEGER*4 N
      INTEGER*2 OUT(N)
      INTEGER*4 DIMES(3),ISC
      OUT(1)=ISC
      OUT(2)=DIMES(1)
      OUT(3)=DIMES(2)
      OUT(4)=DIMES(3)
      RETURN
      END
      SUBROUTINE DIVIDE(OUT,IN,N)
C
C      SCALES AN INPUT ARRAY TO VALUES FROM 0 TO 3
C
      INTEGER*2 IN(N),OUT(N)
      MIN=IN(1)
      MAX=IN(1)
        DO 100 I=1,N
            IF (IN(I).GT.MAX) MAX=IN(I)
            IF (IN(I).LT.MIN) MIN=IN(I)
  100    CONTINUE
      IF (MIN.EQ.MAX) THEN
        IDIFF=1
      ELSE
         IDIFF=MAX-MIN
      END IF
        DO 300 I=1,N
           OUT(I)=INT( REAL(IN(I)-MIN) * 4.0 / REAL(IDIFF) )
           IF (OUT(I).LT.0) OUT(I)=0
           IF (OUT(I).GT.3) OUT(I)=3
  300    CONTINUE
      RETURN
      END
