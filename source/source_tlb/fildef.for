	PROGRAM FILDEF
C
C+	PROGRAM FILDEF
C
C	ALLOWS INTERACTIVE CURSOR DEFINITION OF A 1D (OR AN AXIALLY
C	SYMMETRIC 2D) IMAGE THAT IS TO BE USED AS A LOW-PASS FILTER
C	TRANSFER FUNCTION. A (LOG) DISPLAY OF A POWER SPECTRUM IS PUT
C	UP USING SIMPLEPLOT , THEN THE USER SPECIFIES A LOWER
C	AND AN UPPER LIMIT, WHICH DEFINES A TOP-HAT TRANSFER FUNCTION.
C	THIS IS COSINE-BELLED, AND, IF NECESSARY SCALED UP TO AN
C	AXIALLY SYMMETRIC 2D-IMAGE. (THE LOWER LIMIT MAY BE LEFT OF THE
C	AXIS, IN WHICH CASE IT IS TAKEN AS ZERO)
C
C	PARAMETERS
C		INPUT:   INPUT POWER SPECTRUM. THIS DETERMINES THE
C			 DIMENSION AND SIZE OF THE OUTPUT IMAGE, SO IF
C			 A NULL RESPONSE IS GIVEN, THESE MUST BE
C			 SPECIFIED SEPARATELY.
C               OUTPUT:   OUTPUT FILTER FUNCTION IMAGE
C		NAXIS	IF INPUT=NULL - THE DIMENSIONS OF THE OUTPUT
C		AXIS	IF INPUT=NULL - THE SIZE OF THE OUTPUT
C                       (IE 1 OR 2 VALUES DEPENDING ON NAXIS)
C
C	WFL RGO FEB 1981
C-
	IMPLICIT INTEGER (A-Z)
      INCLUDE 'INTERIM(ERRPAR)'
      INCLUDE 'INTERIM(FMTPAR)'
	INTEGER AXIS(2)
	LOGICAL INNULL
	DATA AXIS/1,1/
C
C	NOW READ THE INPUT FRAME
C
10	CALL RDIMAG('INPUT',FMT_R,2,AXIS,NAXIS,INPTR,STATUS)
	INNULL=STATUS.EQ.ERR_PARNUL
C
C	IF NULL RESPONSE THEN GET NAXIS AND AXIS
C
	IF (INNULL) THEN
20		CALL RDKEYI('NAXIS',.FALSE.,1,NAXIS,I,STATUS)
		IF (STATUS.NE.ERR_NORMAL) THEN
			CALL CNPAR('NAXIS',STATUS)
			GOTO 20
		ENDIF
		IF (NAXIS.LT.1.OR.NAXIS.GT.2) THEN
			CALL WRUSER('MUST BE 1 OR 2',STATUS)
			CALL CNPAR('NAXIS',STATUS)
			GOTO 20
		ENDIF
30		CALL RDKEYI('AXIS',.FALSE.,2,AXIS,I,STATUS)
		IF (STATUS.NE.ERR_NORMAL) THEN
			CALL CNPAR('AXIS',STATUS)
			GOTO 30
		ENDIF
		IF (I.NE.NAXIS) THEN
			CALL WRUSER('MUST BE NAXIS VALUES',STATUS)
			CALL CNPAR('AXIS',STATUS)
			GOTO 30
		ENDIF
	ELSE IF (ERROR.NE.ERR_NORMAL) THEN
		CALL WRUSER('ERROR GETTING INPUT',STATUS)
		CALL CNPAR('INPUT',STATUS)
		GOTO 10
	ENDIF
C
C	NOW GET THE OUTPUT FRAME
C
40	CALL WRIMAG('OUTPUT',FMT_R,AXIS,NAXIS,OUTPTR,STATUS)
	IF (STATUS.NE.ERR_NORMAL) THEN
		CALL CNPAR('OUTPUT',STATUS)
		GOTO 40
	ENDIF
C
C	IF THE INPUT FRAME WAS NULL, GIVE INPTR A VALUE TO AVOID
C	ERROR ON ENTERING ROUTINE FILDEF2
C
	IF (INNULL) THEN
		INPTR=OUTPTR
	ENDIF
C
C	ROUTINE FILDEF2 DOES THE WORK
C
	CALL FILDEF2(%VAL(INPTR),AXIS(1),AXIS(2),.NOT.INNULL,
     +		%VAL(OUTPTR))
C
C	FREE DATA AND STOP
C
	CALL FRDATA(' ',STATUS)
	CALL EXIT
	END
C
	SUBROUTINE FILDEF2(INPUT,M,N,DISPLAY,OUTPUT)
C
C	ROUTINE TO DISPLAY THE POWER SPECTRUM IN INPUT (PROVIDED THAT
C	"DISPLAY" IS TRUE), OR ITS AXIAL MEAN IF IT IS A 2D IMAGE, THEN
C	ALLOW TWO LIMITS TO BE DEFINED. THESE LIMITS ARE USED TO DEFINE
C	A COSINE-BELLED TOP-HAT TRANSFER FUNCTION. NOTE THAT IF N IS
C	ONE THEN THE INPUT ARRAY IS ASSUMED TO BE 1D.
C
C	ARGUMENTS
C		INPUT	REAL 2D ARRAY	INPUT POWER SPECTRUM (NOT USED
C					IF DISPLAY IS FALSE
C		M/N	INTEGER		DIMENSIONS OF INPUT
C		DISPLAY	LOGICAL		TRUE IFF INPUT IS TO BE
C					DISPLAYED
C		OUTPUT	REAL 2D ARRAY	OUTPUT - SAME SIZE AS INPUT
C
C	WFL RGO FEB 1981
C
	REAL INPUT(0:M-1,0:N-1),OUTPUT(0:M-1,0:N-1)
	INTEGER LIMS(2)
	LOGICAL DISPLAY,DIM1
	PARAMETER (PI=3.141592654)
	DIM1=N.EQ.1
	MM1=M-1
	NM1=N-1
	MD2=M/2
	ND2=N/2
C
C	IF DISPLAY IS TRUE AND INPUT IS 1D, USE THE INPUT ARRAY
C	DIRECTLY. OTHERWISE, IF IT IS 2D, CALCULATE THE AXIAL MEAN
C	IN THE FIRST PART OF "OUTPUT" AND IF DISPLAY IS FALSE, DO
C	LIKEWISE, BUT INSTEAD CLEAR THE FIRST PART OF OUTPUT TO
C	ZEROES
C
	MAXRAD=SQRT(REAL(MD2)*REAL(MD2)+REAL(ND2)*REAL(ND2))
	MAXRADP1=MAXRAD+1
	IF (DISPLAY) THEN
		IF (DIM1) THEN
			CALL LIMITS2(INPUT,M,.TRUE.,LIMS)
		ELSE
C
C			NOTE USE OF OUTPUT AS WORKSPACE - SHOULD
C			REALLY CHECK THAT THERE IS ENOUGH ROOM
C
			IF (3*MAXRADP1/2.GT.M*N) THEN
				CALL WRUSER('MARTIANS EXIST - SEE WFL',
     +					STATUS)
				GOTO 999
			ENDIF
			I=MAXRADP1/M
			J=MAXRADP1-I*M
			CALL AXMEAN(INPUT,M,N,OUTPUT,OUTPUT(J,I),
     +				MAXRADP1)
			CALL LIMITS2(OUTPUT,MAXRADP1,.TRUE.,LIMS)
		ENDIF
	ELSE
		OUTPUT(0,0)=1.0
		DO I=1,MAXRAD
			OUTPUT(I,0)=0.0
		ENDDO
		CALL LIMITS2(OUTPUT,MAXRADP1,.TRUE.,LIMS)
	ENDIF
C
C	NOW WE HAVE THE LIMITS, WE CAN SET UP THE TRANSFER FUNCTION
C
	DELTA=REAL(LIMS(2)-LIMS(1))/8.0
	IF (LIMS(1).LE.0) THEN
		LIMS(1)=LIMS(1)-DELTA
	ENDIF
	DO I=0,NM1
		DO J=0,MM1
			RI=MIN(I,N-I)
			RJ=MIN(J,M-J)
			RAD=SQRT(RI*RI+RJ*RJ)
			IF (RAD.LE.LIMS(1)) THEN
				OUTPUT(J,I)=0.0
			ELSE IF (RAD.LT.LIMS(1)+DELTA) THEN
				OUTPUT(J,I)=(1.0-COS(PI*(RAD-LIMS(1))/
     +					DELTA))/2.0
			ELSE IF (RAD.LE.LIMS(2)-DELTA) THEN
				OUTPUT(J,I)=1.0
			ELSE IF (RAD.LT.LIMS(2)) THEN
				OUTPUT(J,I)=(1.0-COS(PI*(LIMS(2)-RAD)/
     +					DELTA))/2.0
			ELSE
				OUTPUT(J,I)=0.0
			ENDIF
		ENDDO
	ENDDO
C
C	AND RETURN
C
999	RETURN
	END
C
	SUBROUTINE AXMEAN(INPUT,M,N,OUTPUT,TOTAL,RSIZE)
C
C	ROUTINE TO ACCEPT A REAL 2D POWER SPECTRUM AND CALCULATE THE
C	AXIAL MEAN, SENDING THE RESULT TO A REAL OUTPUT IMAGE
C
C	ARGUMENTS
C		INPUT	REAL 2D ARRAY	INPUT ARRAY
C		M/N	INTEGERS	DIMENSIONS OF INPUT
C		OUTPUT	REAL 1D ARRAY	OUTPUT ARRAY
C		TOTAL	INTEGER 1D ARR	WORKSPACE
C		RSIZE	INTEGER		LENGTH OF OUTPUT,TOTAL
C
C	WFL RGO FEB 1981
C
	INTEGER RSIZE,RMAX,RLENG
	REAL INPUT(0:M-1,0:N-1),OUTPUT(0:RSIZE-1)
	INTEGER TOTAL(0:RSIZE-1)
C
C	SET UP LOCAL VARIABLES FOR CONVENIENT ARRAY HANDLING
C
	MM1=M-1
	NM1=N-1
	MD2=M/2
	ND2=N/2
	RMAX=SQRT((REAL(MD2))*(REAL(MD2))+(REAL(ND2))*(REAL(ND2)))
	RLENG=RSIZE-1
	SCALE=REAL(RLENG)/REAL(RMAX)
C
C	EMPTY TOTAL AND OUTPUT
C
	DO I=0,RLENG
		TOTAL(I)=0
		OUTPUT(I)=0.0
	ENDDO
C
C	AND GO THROUGH THE INPUT DATA, TOTALLING CONTRIBUTIONS IN
C	IN THE OUTPUT ARRAY
C
	DO I=0,NM1
		DO J=0,MM1
			RI=MIN(I,N-I)
			RJ=MIN(J,M-J)
			K=SCALE*SQRT(RI*RI+RJ*RJ)
			TOTAL(K)=TOTAL(K)+1
			OUTPUT(K)=OUTPUT(K)+INPUT(J,I)
		ENDDO
	ENDDO
C
C	NOW CALCULATE THE AVERAGE VALUES
C
	DO I=0,RLENG
		OUTPUT(I)=OUTPUT(I)/MAX(1,TOTAL(I))
	ENDDO
C
C	AND RETURN
C
	RETURN
	END
	SUBROUTINE LIMITS2(INPUT,ISIZE,LLOG,LIMS)
C
C+	ROUTINE TO PLOT THE 1D ARRAY INPUT USING SIMPLEPLOT, THEN
C	READ TWO LIMITS USING THE CURSOR
C
C	ARGUMENTS	INPUT	INTEGER ARRAY	INPUT ARRAY
C			ISIZE	INTEGER		LENGTH OF INPUT
C			LLOG	LOGICAL		TRUE IFF LOG
C						DISPLAY NEEDED
C			LIMS	INTEGER ARRAY	SELECTED LIMITS
C
C	WFL FEB 1981 RGO
C
	INTEGER LIMS(2),STATUS
	REAL INPUT(0:ISIZE-1),XVALS(0:2047),YVALS(0:2047)
	CHARACTER LR(2)*1,VAL*4
	LOGICAL LLOG
	DATA LR/'L','R'/
	ISIZEM1=ISIZE-1
C
C	USE 2048 COORDINATES (UNLESS ISIZE<2048)
C
	NVALS=MIN(ISIZE,2048)
	DO I=0,NVALS-1
		J=(I*ISIZEM1)/(NVALS-1)
		XVALS(I)=J
		IF (LLOG) THEN
			YVALS(I)=MAX(INPUT(J),0.0)+1
		ELSE
			YVALS(I)=INPUT(J)
		ENDIF
	ENDDO
C
C	NOW USE SIMPLEPLOT TO PLOT THE ARRAY
C
	IF (LLOG) THEN
		NVALS2=-NVALS
	ELSE
		NVALS2=NVALS
	ENDIF
        CALL JBDEV('2')
	CALL JBAXES(XVALS,NVALS,18.0,'BINS',4,
     +		   YVALS,NVALS2,15.0,'COUNTS',6)
	CALL DRAWCV(XVALS,YVALS,NVALS)
C
C	SIMPLEPLOT WILL HAVE CALLED T4010 AND WILL HAVE ALSO
C	CALLED WINDOL SO THAT USER COORDS ARE DEVICE COORDS
C
C	DEFINE THE FOLLOWING CURSOR KEYS:-
C		L	LEFT LIMIT
C		R	RIGHT LIMIT
C
C	AND INFORM USER OF THE ONLY HONOURABLE COURSE OF ACTION
C
	ICURSE=0
	LIMS(1)=32767
	LIMS(2)=-32768
	CALL CURDEF('LR*.')
	CALL WRUSER('USE THE CURSOR TO DEFINE LEFT AND RIGHT '//
     +	'LIMITS',STATUS)
	CALL WRUSER('L	LEFT LIMIT',STATUS)
	CALL WRUSER('R	RIGHT LIMIT',STATUS)
C
C	READ CURSOR UNTIL L AND R ARE DEFINED OK
C
	DO WHILE (LIMS(1).GE.LIMS(2))
		CALL CURSOR(X,Y)
		IF (ICURSE.LE.2) THEN
			LIMS(ICURSE)=X+0.5
			WRITE (VAL,'(I4)') LIMS(ICURSE)
			CALL WRUSER(LR(ICURSE)//' VALUE IS'//
     +			VAL,STATUS)
		ELSE
			CALL WRUSER('ILLEGAL KEY',STATUS)
		ENDIF
	ENDDO
	CALL ENDPLT
	RETURN
	END
