C++
C
C      STARLINK ENVIRONMENT PROGRAM   *** EXPAND ***
C
C      WRITTEN BY K F HARTLEY AT RGO ON 9/11/80
C
C      VERSION #2
C
C      GIVEN A 2-D STARLINK IMAGE IT EXPANDS PART OF IT BY A
C      GIVEN FACTOR UP TO AN ARRAY OF THE SAME SIZE AS THE ORIGINAL.
C      (DEFAULT) OR OF DIFFERANT SIZE ( IN VERSION 2 )!
C
C      THE TECHNIQUE USED IS TO INTERPOLATE NEW DATA VALUES BETWEEN
C      THE OLD ONES , BUT SINE(THETA)/THETA , RATHER THAN LINEAR ,
C      INTERPLOATION IS USED.
C      PROVIDED THE ORIGINAL IMAGE WAS MARGINALLY OVERSAMPLED
C      THE INTERPOLATION DOES NOT MODIFY THE FOURIER TRANSFORM OF
C      THE IMAGE .
C      UNFORTUMATELY WE HAVE TO USE A CUBIC SPLINE APPROXIMATION
C      TO THE SINC FUNCTION , ,WHICH DOES HAVE SOME IMPACT ON THE
C      TRANSFORM , BUT VERY LITTLE .
C
C      THE PARAMETERS ARE:
C
C          INPUT:     THE INPUT IMAGE
C
C          SIZEOFOU:  THE DIMENSIONS OF THE OUTPUT ARRAY
C
C          OUTPUT:    THE OUTPUT IMAGE
C
C          XYOFCEN:   THE COORDINATES OF THE PIXEL IN THE INPUT IMAGE
C                     ABOUT WHICH AN AREA IS TO BE EXPANDED TO FILL THE
C                     OUTPUT ARRAY WITH A MAGN AS SPECIFIED.
C
C          MAGN:      THE MAGNIFICATION TO BE APPLIED
C                     (CAN BE NON-INTEGER)
C
C
C--

C
C   Modified to handle REAL images by K F Hartley 13/4/83
C
      INTEGER*4 AXISO(2),AXIS(2),STATUS,XC,YC,CEN(2),PIN,POUT
      REAL*4 FACTOR
      INCLUDE 'INTERIM(FMTPAR)'
C
C      GET THE TWO ARRAYS OLD AND NEW
C
      CALL RDIMAG('INPUT',FMT_R,2,AXIS,I,PIN,STATUS)
      IF (STATUS.NE.0.OR.I.NE.2) THEN
         CALL WRERR('HELLIN')
         CALL EXIT
      END IF
C
C      NOW PICK UP SIZE OF OUTPUT IMAGE
C
      AXISO(1)=AXIS(1)
      AXISO(2)=AXIS(2)
      CALL WRUSER('ENTER DIMENSIONS OF OUTPUT FRAME',STATUS)
   50 CALL RDKEYI('SIZEOFOU',.TRUE.,2,AXISO,I,STATUS)
      IF (STATUS.GT.2.OR.I.EQ.1.OR.I.GT.2.OR.AXISO(1).LT.2.
     1    OR.AXISO(2).LT.2) THEN
          CALL WRERR('HELL')
          CALL CNPAR('SIZEOFOU',STATUS)
          IF (STATUS.NE.0) THEN
             CALL EXIT
          ELSE
             GO TO 50
          END IF
       END IF
      CALL WRIMAG('OUTPUT',FMT_R,AXISO,2,POUT,STATUS)
      IF (STATUS.NE.0) THEN
         CALL WRERR('HELLOUT')
         CALL EXIT
      END IF
C
C      NOW PICK UP THE THREE PARAMETERS
C
C
C      SET DEFAULT CENTRE OF NEW IMAGE TO CENTRE OF OLD IMAGE
C      Modified by KFH 13/4/83 to give better default values
C
      CEN(1)=(AXIS(1)+1)/2
      CEN(2)=(AXIS(2)+1)/2
      CALL WRUSER('ENTER CO-ORDS OF POINT TO BE CENTRE OF NEW IMAGE',
     1               STATUS)
  100 CALL RDKEYI('XYOFCEN',.TRUE.,2,CEN,I,STATUS)
      IF ((STATUS.GT.1).OR.(I.EQ.1.OR.I.GT.2).
     1    OR.(CEN(1).LT.1.OR.CEN(1).GT.AXIS(1)).OR.
     2       (CEN(2).LT.1.OR.CEN(2).GT.AXIS(2)))
     3              THEN
                       CALL WRERR('HELL')
                       CALL CNPAR('XYOFCEN',STATUS)
                       IF (STATUS.NE.0) THEN
                          CALL EXIT
                       ELSE
                          GO TO 100
                       END IF
                    END IF
C
C      SET DEFAULT FACTOR AS 1.0
C
      FACTOR=1.0
      CALL WRUSER('ENTER MAGNIFICATION +VE,NEED NOT BE AN INTEGER',
     1             STATUS)
  200 CALL RDKEYR('MAGN',.TRUE.,1,FACTOR,I,STATUS)
      IF (STATUS.GT.1.OR.FACTOR.LT.1.0) THEN
         CALL WRERR('HELL')
         CALL CNPAR('MAGN',STATUS)
         IF (STATUS.NE.0) THEN
            CALL EXIT
         ELSE
            GO TO 200
         END IF
      END IF
C
C      NOW CALL ALGORITHM
C
      CALL EXPAND(%VAL(PIN),%VAL(POUT),AXIS(1),AXIS(2),AXISO(1),
     1            AXISO(2),FACTOR,CEN(1),CEN(2))
      CALL FRDATA(' ',STATUS)
      CALL EXIT
      END
      SUBROUTINE EXPAND(IN,OUT,N,M,JN,JM,FACTOR,XC,YC)
C
C      THIS ROUTINE IS BASED ON ONE WRITTEN BY C D PIKE (RGO)
C      AS PART OF RGODR .
C      THE TWO ROUTINES CALLED (INTERX AND INTERY COME UNCHANGED
C      FROM THERE
C
C      PARAMETERS :-
C         IN IS THE ORIGINAL IMAGE , OUT THE NEW IMAGE
C         IN IS OF SIZE N BY M AND OF TYPE REAL
C         OUT IS OF SIZE JN BY JM AND ALSO OF TYPE REAL
C         FACTOR IS THE (REAL , >1) MAGNIFICATION
C         XC,YC IS THE CO-ORDINATES OF THE POINT IN THE OLD IMAGE
C         WHICH WILL BECOME THE CENTRE OF THE NEW IMAGE.
C
C         Modified from I*4 to REAL by KFH on 13/4/83
C         and workspace increased to 4096 fro 2048
C
      INTEGER*4 XC,YC
      REAL*4 WORK(4096),IN(N,M),OUT(JN,JM),NOUT(4096)
      CHARACTER*72 LIST
      CHARACTER*18 MESS
C
C      NOUT AND WORK ARE WORKING BUFFERS , AND LIMIT THE MAXIMUM
C      VALUE OF N TO 4096
C
C      FIRST WE FIND THE START AND END X,Y COORDS OF THE PART OF
C      IN TO BE EXPANDED , MAKING SURE IT IS WHOLLY WITHIN THE ARRAY
C
      XS=FLOAT(JN)/FACTOR
      YS=FLOAT(JM)/FACTOR
C
C      THE CORNER VALUES ARE ADJUSTED BY + OR - 1 TO REMOVE ROUND-OFF
C      GIVING TOO MANY NEW PIXELS FOR THE NEW ARRAY .
C      (This was taken out by KFH on 13/4/83 to try
C       to avoid borders of zeroes.)
C
      N1=XC-IFIX(XS/2.0)
      N2=XC+IFIX(XS/2.0)
      M1=YC-IFIX(YS/2.0)
      M2=YC+IFIX(YS/2.0)
      IF (N1.LT.1) N1=1
      IF (N2.GT.N) N2=N
      IF (M1.LT.1) M1=1
      IF (M2.GT.M) M2=M
C
C      HAVING FIXED THE CORNERS...
C      ...FIND OUT HOW MANY PIXELS IN EACH DIRECTION
C
      NX=N2-N1+1
      NY=M2-M1+1
C
C      AND ADD A COUPLE TO ALLOW INTERPLOLATION TO THE EDGES
C      (Increased to 4 by KFH on 13/4/83)
C
      NXA=NX+4
      NYA=NY+4
C
C      NOW WORK OUT HOW MANY PIXELS IN THE NEW ARRAY
C      (Adding 1 to handle round-off by KFH on 13/4/83)
C
      NOX=IFIX(FACTOR*FLOAT(NX+1)+0.5)
      NOY=IFIX(FACTOR*FLOAT(NY+1)+0.5)
C
C      NOW START THE INTERPOLATION
C      FIRST IN X DIRECTION
C
      DO 200 J=1,NYA
         JJ=J+M1-2
         DO 100 I=1,NXA
            II=I+N1-2
            NOUT(I)=IN(II,JJ)
  100    CONTINUE
         CALL INTERX(NOUT,WORK,J,N1,N2,M1,M2,NOX,NOY,OUT,JN,JM)
  200 CONTINUE
      CALL WRUSER('FINISHED X-INTERPOLATION',ISTAT)
C
C      NOW INTERPOLATE IN Y
C
      J1=0
C
C      BUT FIRST SET UP AN ENCOURAGING MESSAGE
C
      MESS='INTERPOLATING LINE'
      DO 300 J=1,NOX
         CALL INTERY(WORK,J,N1,N2,M1,M2,NOX,NOY,NOUT,OUT,JN,JM)
         IF (MOD(J,20).EQ.0) THEN
            WRITE (LIST,'(A,2X,I4)') MESS,J
            CALL WRUSER(LIST,ISTAT)
         END IF
  300 CONTINUE
C
C      NOW SET ANY REMAINING PIXELS AT THE EDGES TO 0
C
C      This hs been modified to do it properly by
C      KFH on 13/4/83
C
      IF (NOY.LT.JM) THEN
         DO 400 J=NOY+1,JM
           DO 350 I=1,JN
              OUT(I,J)=0
  350    CONTINUE
  400    CONTINUE
      END IF
      IF (NOX.LT.JN) THEN
         DO 500 J=1,JM
            DO 450 I=NOX+1,JN
                  OUT(I,J)=0
  450         CONTINUE
  500       CONTINUE
      END IF
C
C     NOW RETURN WITH THE RESULTS SAFELY IN "OUT"
C
      END
      SUBROUTINE INTERX(IWORK,WORK,J,NX1,NX2,NY1,NY2,NOX,NOY,ICORE2,
     1NX,NY)
C
C
C     STEP IS THE SPACING IN THE INPUT PICTURE CORRESPONDING TO ONE OUTP
C
C   A,B,C,D  ARE THE CURRENT INTERPOLATION VALUES THESE ARE UPDATED AS T
C   OUTPUT POINTER MOVES THRO' THE DATA
C
C    THE INTERMEDIATE ARRAY 'WORK' CONTAINS THE ORIGINAL NO OF LINES
C   WINDOWED IN Y (+2) BUT THE FULL SET OF INTERPOLATED VALUES IN X
C
C  THE LIMITING ONES (1 & NOX) ARE TAKEN AS THE ORIGINAL DATA POINTS
C
C   Modified by KFH to handle REAL data and a workspace of 4096
C   by KFH on 13/4/83
C
      DIMENSION WORK(NOX)
      REAL IWORK(4096),ICORE2(NX,NY)
C
C   BEWARE THAT J IS TOO LARGE
C
      IF (J.GT.NY) RETURN
      STEP = FLOAT(NX2-NX1)/FLOAT(NOX-1)
      DIST = 0.0
      ICOUNT = 1
      NOX1 = NOX-1
      DO 100 N=2,NOX1
      DIST = DIST + STEP
      IF(DIST.LE.1.0)  GO TO 50
      ICOUNT = ICOUNT + 1
      DIST = DIST - 1.0
   50 CONTINUE
      A = IWORK(ICOUNT)
      B = IWORK(ICOUNT + 1)
      C = IWORK(ICOUNT + 2)
      D = IWORK(ICOUNT + 3)
      WORK(N) = A*SAMPLE(1.0+DIST) + B*SAMPLE(DIST)
     1 + C*SAMPLE(1.0-DIST) + D*SAMPLE(2.0-DIST)
C
C      The original had the following line present
C      Removed by KFH on 21/4/83
C
C.....WORK(N) = MAX(WORK(N),0.0)
  100 CONTINUE
      WORK(1) = (IWORK(2))
      NX22 = 2+NX2-NX1
      WORK(NOX) = (IWORK(NX22))
C
C
C
C   BEWARE THE INTEGERIZATION BELOW DOESNT LOSE ACCURACY
C   Removed by KFH on 21/4/83
C
      DO 150 I=1,NOX
         IF (I.LE.NX) THEN
            ICORE2(I,J) = WORK(I)
         END IF
  150 CONTINUE
C
      END
C
C
C
C
C
C
C
C
C
C
      SUBROUTINE INTERY(WORK,J,NX1,NX2,NY1,NY2,NOX,NOY,NOUT,ICORE2,
     1NX,NY)
C
C           SUB TO DO THE SAME INTERPOLATION IN Y. STARTS WITH THE INTER
C            ARRAY 'WORK' AND OUTPUTS THE INTEGERIZED ARRAY 'NOUT'
C
C      Modified to handle REAL data and a workspace of 4096
C      by KFH on 13/4/83
C
      DIMENSION WORK(4096)
      REAL NOUT(NOY),ICORE2(NX,NY)
C
C   BEWARE THAT J IS OUT OF RANGE
C
      IF (J.GT.NX) RETURN
      NYA = NY2-NY1+3
      DO 75 I=1,NYA
         IF (I.LE.NY) THEN
            WORK(I) = (ICORE2(J,I))
         END IF
   75 CONTINUE
      STEP = FLOAT(NY2-NY1)/FLOAT(NOY-1)
      DIST = 0.0
      ICOUNT = 1
      NOUT(1) = WORK(2)
      NOYM1 = NOY - 1
      DO 100 N=2,NOYM1
      DIST = DIST + STEP
      IF(DIST.LE.1.0)  GO TO 50
      ICOUNT = ICOUNT + 1
      DIST = DIST - 1.0
   50 CONTINUE
      A = WORK(ICOUNT)
      B = WORK(ICOUNT+1)
      C = WORK(ICOUNT + 2)
      D = WORK(ICOUNT+ 3)
      VALUE = A*SAMPLE(1.0 + DIST) + B*SAMPLE(DIST)
     1 + C*SAMPLE(1.0-DIST) + D*SAMPLE(2.0-DIST)
      NOUT(N) = VALUE
C
C     The following line was removed by KFh on 21/4/83
C
C.....NOUT(N) = MAX(NOUT(N),0.0)
  100 CONTINUE
      NYB = NY2-NY1 + 2
      NOUT(NOY) = WORK(NYB)
C
C      The following line was removed by KFH on 21/4/83
C
C.....NOUT(NOY) = MAX(NOUT(NOY),0.0)
      DO 200 I=1,NOY
         IF (I.LE.NY) THEN
            ICORE2(J,I) = NOUT(I)
         END IF
  200 CONTINUE
      END
C
C
C
C
C
C
C
C
C
C
      FUNCTION SAMPLE(X)
C
C    THE INTERPOLATION USING SINC FUNCTION
C
      X = ABS(X)
      IF(X.GE.0.0.AND.X.LE.2.0)  GO TO 10
      SAMPLE = 0.0
      RETURN
   10 IF(X.GE.1.0)  GO TO 20
      SAMPLE = 1.0 - 2.0*X*X + X*X*X
      RETURN
   20 SAMPLE = 4.0 - 8.0*X + 5.0*X*X - X*X*X
      RETURN
      END
C
C
C
C
C
C
C
C
C
C
