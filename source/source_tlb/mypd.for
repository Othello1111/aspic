	PROGRAM PROGDOC
	IMPLICIT INTEGER (A-Z)
      INCLUDE 'INTERIM(FMTPAR)'
      INCLUDE 'INTERIM(ERRPAR)'
	EXTERNAL STORE_HELP
	PARAMETER (MAXAUTH=100,MAXKEY=100,LBR$C_UPDATE='0002'X,
	1	LBR$_KEYNOTFND='00269062'X,NSRC=42,NCON=43,NOUT=44)
	CHARACTER LIBRARY*80,SOURCE*80,MODE*1,SRCDIRY*80,CONDIRY*80,
	1	AUTHOR*5,KEYREC*80,USERKEYS(20)*16,AUTHLIST(MAXAUTH)*5,
	1	KEYLIST(MAXKEY)*16,FILETYPE*4,KEYNAME*20,CALL_LINE*80,
	1	BUFF*80
	LOGICAL DELETE,CON_THERE,NO_KEY,LOCATE
	INTEGER OLD_TEXT(2),NEW_TEXT(2)
	COMMON/READ_HELP/RECORD_COUNT,MAX_COUNT,REQ_LEVEL
C
C	READ THE NAME OF THE SOURCE FILE
C
10	CALL RDKEYC('SOURCE',.FALSE.,1,SOURCE,I,STATUS)
	CALL STR$UPCASE(SOURCE,SOURCE)
C
C	DETERMINE WHETHER A FILETYPE IS GIVEN AND SET 'FILETYPE'
C	AS APPROPRIATE
C
	END_DIR=MAX(INDEX(SOURCE,']'),INDEX(SOURCE,':'))
	START_TYPE=END_DIR+INDEX(SOURCE(END_DIR+1:)//'.','.')
	IF (START_TYPE.GT.LEN(SOURCE)) THEN
		FILETYPE='.FOR'
	ELSE
		FILETYPE='    '
	ENDIF
C
C	TRY TO OPEN THE FILE. IF FAIL THEN READ
C	'SRCDIRY' AND RETRY
C
	OPEN(UNIT=NSRC,FILE=SOURCE//FILETYPE,STATUS='OLD',
	1	READONLY,SHARED,IOSTAT=STATUS)
	IF (STATUS.NE.0) THEN
		CALL RDKEYC('SRCDIRY',.FALSE.,1,SRCDIRY,I,STATUS)
		OPEN(UNIT=NSRC,FILE=SRCDIRY//SOURCE//FILETYPE,
	1		STATUS='OLD',READONLY,SHARED,IOSTAT=STATUS)
		IF (STATUS.NE.0) THEN
			CALL WRUSER('UNABLE TO OPEN SOURCE FILE',
	1			STATUS)
			CALL CNPAR('SOURCE',STATUS)
			CALL CNPAR('SRCDIRY',STATUS)
			GOTO 10
		ENDIF
	ENDIF
C
C   Open a .DOC file to recieve the information.
C
      KEYNAME=SOURCE(END_DIR+1:START_TYPE-1)
      OPEN (UNIT=NOUT,FILE=KEYNAME//'.DOC',STATUS='NEW',
     :		CARRIAGECONTROL='LIST')
C
C	DETERMINE WHETHER IN PROGRAM OR SUBROUTINE MODE
C
20		CALL RDKEYC('MODE',.FALSE.,1,MODE,I,STATUS)
		IF (MODE.NE.'P'.AND.MODE.NE.'S') THEN
			CALL WRUSER('MODE MUST BE "PROGRAM" '//
	1		'OR "SUBROUTINE"',STATUS)
			CALL CNPAR(MODE,STATUS)
			GOTO 20
		ENDIF
C
C	IF IN PROGRAM MODE, ATTEMPT TO OPEN THE CONNECTION FILE
C
		IF (MODE.EQ.'P') THEN
			OPEN(UNIT=NCON,FILE=SOURCE(:START_TYPE-1)//'.CON',
	1		STATUS='OLD',READONLY,SHARED,IOSTAT=STATUS)
			IF (STATUS.NE.0) THEN
				CALL RDKEYC('CONDIRY',.FALSE.,1,CONDIRY,
	1			I,STATUS)
				OPEN(UNIT=NCON,FILE=CONDIRY//SOURCE
	1			(:START_TYPE-1)//'.CON',STATUS='OLD',
	1			READONLY,SHARED,IOSTAT=STATUS)
				CON_THERE=STATUS.EQ.0
			ELSE
				CON_THERE=.TRUE.
			ENDIF
		ENDIF
C
C	MOST OF THE WORK IS WHEN UPDATING OR CREATING AN ENTRY.
C	FIRST OF ALL, PUT THE SOURCE DOCUMENTATION INTO THE TOP
C	LEVEL HELP ENTRY, RETURNING THE SUBROUTINE CALL LINE IF
C	FOUND
C
	CALL TRANS_SOURCE(KEYNAME,CALL_LINE)
C
C	NOW, DEPENDING ON MODE, HANDLE THE CONNECTION FILE/
C	CALL LINE
C
	IF (MODE.EQ.'P'.AND.CON_THERE) THEN
		CALL TRANS_CON(NEW_TEXT)
	ELSE IF (MODE.EQ.'S'.AND.CALL_LINE.NE.' ') THEN
		CALL TRANS_CALL(CALL_LINE)
	ENDIF
C
C	PROMPT THE USER FOR THE AUTHOR
C
	CALL RDKEYC('AUTHOR',.TRUE.,1,AUTHOR,I,STATUS)
	CALL TRANS_AUTH(AUTHOR)
C
C	FINALLY, THE DATE
C
	CALL TRANS_DATE(LIB_INDEX,NEW_TEXT)
C
C	BYE BYE
C
	CALL EXIT
	END
C
	SUBROUTINE CHECK(STATUS)
	IMPLICIT INTEGER (A-Z)
	CHARACTER BUFADR*256
	IF (.NOT.STATUS) THEN
		GSTATUS=SYS$GETMSG(%VAL(STATUS),MSGLEN,BUFADR,%VAL(15),)
		IF (GSTATUS) THEN
			PRINT *,BUFADR(:MSGLEN)
		ELSE
			PRINT '(A,Z8)',' SYS$GETMSG STATUS IS ',GSTATUS
		ENDIF
		CALL EXIT
	ELSE
		RETURN
	ENDIF
	END
C
	SUBROUTINE TRANS_SOURCE(KEY,CALL)
	IMPLICIT INTEGER(A-Z)
	PARAMETER (NSRC=42,NOUT=44)
	INTEGER TEXT(2)
	LOGICAL WRITING,FOUND_CALL,COMMENT,PLUS,MINUS,P_OR_M
	CHARACTER*(*) KEY,CALL
	CHARACTER BUFF*80,C*1
C
C	STATEMENT FUNCTIONS
C
	COMMENT(I)=BUFF(I:I).EQ.'c'.OR.BUFF(I:I).EQ.'C'.OR.
	1	BUFF(I:I).EQ.'*'.OR.BUFF(I:I).EQ.';'.OR.BUFF(I:I).EQ.'!'
	PLUS(I)=BUFF(I:I).EQ.'+'
	MINUS(I)=BUFF(I:I).EQ.'-'
	P_OR_M(I)=PLUS(I).OR.MINUS(I)
C
C	INITIALISE AND WRITE THE PRIMARY KEY RECORD
C
	CALL=' '
	BUFF='2 '//KEY
	WRITE (NOUT,'(A)') BUFF
	BUFF=' '
C
C	READ THE SOURCE AND TRANSCRIBE COMMENTS TO THE HELP LIBRARY
C
	WRITING=.FALSE.
	FOUND_CALL=.FALSE.
	READ (UNIT=NSRC,FMT='(A)',IOSTAT=STATUS) BUFF
	DO WHILE (STATUS.EQ.0)
		CALL STPOS(BUFF,START)
		IF (.NOT.FOUND_CALL.AND..NOT.COMMENT(START).AND.(INDEX(BUFF,
	1	'SUBROUTINE').GT.0.OR.INDEX(BUFF,'FUNCTION').GT.0)) THEN
			CALL=BUFF
			FOUND_CALL=.TRUE.
		ENDIF
		WRITING=COMMENT(START).AND.(WRITING.OR.PLUS(START+1))
		IF (WRITING) THEN
			CALL GEN_FLIMCS(BUFF,I,LENGTH)
			END=I+LENGTH-1
			WRITING=.NOT.MINUS(START)
			START=START+1
			DO WHILE (P_OR_M(START))
				START=START+1
			ENDDO
			WRITE (NOUT,'(A)') BUFF(START:END)
		ENDIF
		READ (UNIT=NSRC,FMT='(A)',IOSTAT=STATUS) BUFF
	ENDDO
	RETURN
	END
C
	SUBROUTINE STPOS(BUFF,START)
	IMPLICIT INTEGER(A-Z)
	CHARACTER*(*) BUFF
	CHARACTER TAB*1
	PARAMETER (TAB=CHAR(9))
	DO START=1,LEN(BUFF)
		IF (BUFF(START:START).NE.'$'.AND.
	1	    BUFF(START:START).NE.' '.AND.
	1	    BUFF(START:START).NE.TAB     ) THEN
			RETURN
		ENDIF
	ENDDO
	RETURN
	END
C
	SUBROUTINE TRANS_CON(TEXT)
	IMPLICIT INTEGER(A-Z)
	PARAMETER (NCON=43,NOUT=44)
	INTEGER TEXT(2)
	CHARACTER*80 BUFF
	WRITE (NOUT,900)
  900	FORMAT('3 Parameters',//)
	READ (UNIT=NCON,FMT='(A)',IOSTAT=STATUS) BUFF
	DO WHILE (STATUS.EQ.0)
		CALL GEN_FLIMCS(BUFF,START,LENGTH)
		IF (LENGTH.GT.0) THEN
			WRITE (NOUT,'(A)') BUFF(START:START+LENGTH-1)
		ENDIF
		READ (UNIT=NCON,FMT='(A)',IOSTAT=STATUS) BUFF
	ENDDO
	RETURN
	END
C
	SUBROUTINE TRANS_CALL(CALL)
	IMPLICIT INTEGER(A-Z)
	INTEGER TEXT(2)
	CHARACTER*(*) CALL
	PARAMETER (NOUT=44)
	WRITE (NOUT,900) CALL
  900	FORMAT('3 Parameters',//,'The following is the subroutine',
     :		' call line:-',//,'A')
	RETURN
	END
C
	SUBROUTINE TRANS_AUTH(AUTHOR)
	IMPLICIT INTEGER(A-Z)
	INTEGER TEXT(2)
	CHARACTER*(*) AUTHOR
	PARAMETER (NOUT=44)
	WRITE (NOUT,900) AUTHOR
  900	FORMAT ('3 Author',//,'It was written by ',A)
	RETURN
	END
C
	SUBROUTINE TRANS_DATE(TEXT)
	IMPLICIT INTEGER (A-Z)
	INTEGER TEXT(2)
	CHARACTER TIM*5,DAT*9
	PARAMETER (NOUT=44)
	CALL TIME(TIM)
	CALL DATE(DAT)
	WRITE (NOUT,900) TIM,DAT
  900	FORMAT ('3 date',//,'This entry was made at ',A,
     :		' on ',A)
	RETURN
	END
C
	LOGICAL FUNCTION LOCATE(LIST,LIST_LENG,ITEM)
	IMPLICIT INTEGER (A-Z)
	CHARACTER*(*) LIST(LIST_LENG),ITEM
	CALL GEN_FLIMCS(ITEM,START,LENGTH)
	END=START+LENGTH-1
	CALL STR$UPCASE(ITEM,ITEM)
	DO I=1,LIST_LENG
		IF (INDEX(LIST(I),ITEM(START:END)).GT.0) THEN
			LOCATE=.TRUE.
			RETURN
		ENDIF
	ENDDO
	LOCATE=.FALSE.
	RETURN
	END
C
	FUNCTION STORE_HELP(LINE,FLAGS,ARRAY,LEVEL)
	IMPLICIT INTEGER (A-Z)
	CHARACTER*(*) LINE,ARRAY(*)
	COMMON/READ_HELP/RECORD_COUNT,MAX_COUNT,REQ_LEVEL
	IF (FLAGS.EQ.0.AND.LEVEL.EQ.REQ_LEVEL) THEN
		IF (RECORD_COUNT.LT.MAX_COUNT) THEN
			RECORD_COUNT=RECORD_COUNT+1
		ENDIF
		ARRAY(RECORD_COUNT)=LINE
	ENDIF
	STORE_HELP=1
	RETURN
	END
