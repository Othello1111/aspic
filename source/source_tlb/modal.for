C++
C
C      STARLINK ENVIRONMENT PROGRAM   *** MODAL ***
C
C      WRITTEN BY K F HARTLEY AT RGO ON 10/11/80
C
C      VERSION #1
C
C
C      THIS PROGRAM CREATES A NEW ARRAY FROM A STARLINK 2-D ARRAY
C      IN WHICH EACH ELEMENT OF THE NEW ARRAY IS THE MODE OF THE
C      CORRESPONDING NEIGHBOURHOOD IN THE OLD ARRAY.
C
C      IN FACT TO SAVE ON COMPUTER TIME THE OLD ARRAY IS DIVIDED INTO
C      A SET OF NON-OVERLAPPING BOXES AND THE MODE COMPUTED FOR EACH
C      OF THEM . LINEAR INTERPOLATION IS USED TO FILL IN THE OTHER
C      ELEMENTS REQUIRED .
C
C      THE DETAILS ARE A BIT CRUDE .
C
C      THERE MAY BE RATHER FEW PIXELS IN THE BOX USED TO CALCULATE
C      THE MODE , SO THE HISTOGRAM CONTAINS ONLY 21 BINS .
C      THE MODE IS THEN TAKEN AS THE HISTOGRAM BIN WHICH CONTAINS
C      THE LARGEST NUMBER OF OCCURRENCES .
C      THIS MAY BE CHANGED IF REQUIRED.
C
C      THE USER IS PROMPTED FOR :-
C      INPUT   THE INPUT IMAGE
C      OUTPUT  THE OUTPUT IMAGE ( ? THE RESULT OF APPLYING A "MODAL"
C              FILTER TO INPUT.
C
C      BOX     THIS SHOULD BE AN ODD,POSITIVE INTEGER GREATER THAN 3
C              AND DEFINES THE SIZE OF THE BOX FOR WHICH THE MODE IS
C              COMPUTED.
C
C--
      INTEGER*4 AXIS(2),STATUS,PIN,POUT,BOX
      INCLUDE 'INTERIM(FMTPAR)'
C
C      PICK UP THE INPUT AND OUTPUT IMAGES
C
      CALL RDIMAG('INPUT',FMT_SL,2,AXIS,I,PIN,STATUS)
      IF (STATUS.NE.0.OR.I.NE.2) THEN
            CALL WRERR('HELLIN')
            CALL EXIT
      END IF
      CALL WRIMAG('OUTPUT',FMT_SL,AXIS,2,POUT,STATUS)
      IF (STATUS.NE.0) THEN
            CALL WRERR('HELLOUT')
            CALL EXIT
      END IF
C
C      NOW PICK UP THE BOX SIZE
C      CHECK FOR : BAD STATUS
C                  WRONG NUMBER OF PARAMETERS
C                  VALUE LESS THAN 3
C                  EVEN VALUE
C                  VALUE TOO LARGE ( GIVING TOO FEW MODES FOR INTERPOLATION)
C
C
      BOX=5
  100 CALL RDKEYI('BOX',.TRUE.,1,BOX,I,STATUS)
      IF (STATUS.GT.1.OR.I.GT.1) THEN
            CALL WRERR('HELL1')
            CALL CNPAR('BOX',STATUS)
            IF (STATUS.NE.0) THEN
                  CALL EXIT
            ELSE
                  GO TO 100
            END IF
      END IF
      IF (BOX.LT.3) THEN
         CALL WRERR('HELL2')
         CALL CNPAR('BOX',STATUS)
         IF (STATUS.NE.0) THEN
            CALL EXIT
         ELSE
            GO TO 100
         END IF
      END IF
      NB=AXIS(1)/BOX
      MB=AXIS(2)/BOX
      IREM=2*(BOX/2)-BOX
      IF (IREM.EQ.0.OR.NB.LT.3.OR.MB.LT.3) THEN
         CALL WRERR('HELL3')
         CALL CNPAR('BOX',STATUS)
         IF (STATUS.NE.0) THEN
            CALL EXIT
         ELSE
            GO TO 100
         END IF
      END IF
C
C      HAVING GOT THE PARAMETERS , DO THE WORK
C
      CALL MODAL(%VAL(PIN),%VAL(POUT),AXIS(1),AXIS(2),BOX)
      CALL FRDATA (' ',STATUS)
      CALL EXIT
      END
      SUBROUTINE MODAL(IN,OUT,N,M,IBOX)
C
C      THIS IS BASICALLY AN RGODR ROUTINE WRITTEN BY K F HARTLEY
C
C      IN IS AN INPUT ARRAY ; OUT AN OUTPUT ARRAY BOTH OF SIZE N BY M
C
C      THE ROUTINE APPLIES A MODAL FILTER TO THE INPUT ARRAY , YIELDING
C      THE OUTPUT ARRAY.
C      IBOX DEFINES THE SIZE OF THE BOX OVER WHICH THE MODE IS COMPUTED
C
      INTEGER*4 IN(N,M),OUT(N,M)
C
C      WE ASSUME THAT THE ARRAY USED TO CONTAIN THE MODES WILL BE NO GREATER
C      THAN 512*512 ( AND HENCE THAT THE INPUT ARRAY MUST BE NO MORE
C      THAN 3*512 SQUARE
C      THE HISTOGRAM USED IN COMPUTING THE MODE HAS ONLY 21 ENTRIES
C
      INTEGER*4 IMODE(512,512),IHIST(21)
C
C      WE USE ICHAN AND IXSEC INSTEAD OF N AND M TO AVOID THE
C      POSSIBILITY OF THEIR BEING CORRUPTED.!!!!!
C
      ICHAN=N
      IXSEC=M
C
C      WE FIRST COMPUTE THE NUMBER OF BOXES IN EACH DIRECTION
C      FOR THE INTERPOLATION TO WORK THERE OUGHT TO BE AT LEAST 3 OF THEM
C
C      ( THIS WAS CHECKED IN THE CALLING SEGMENT)
C
      NBOXI=ICHAN/IBOX
      NBOXJ=IXSEC/IBOX
C
C      FORM HISTOGRAM TO OBTAIN MODES
C
      DO 600 JB=1,NBOXJ
       JPS=(JB-1)*IBOX+1
       JPE=JPS+IBOX-1
       DO 500 IB=1,NBOXI
        IPS=(IB-1)*IBOX+1
        IPE=IPS+IBOX-1
        MIN=IN(IPS,JPS)
        MAX=IN(IPS,JPS)
        DO 240 J=JPS,JPE
         DO 220 I=IPS,IPE
          IF (IN(I,J).GT.MAX) MAX=IN(I,J)
          IF (IN(I,J).LT.MIN) MIN=IN(I,J)
  220    CONTINUE
  240   CONTINUE
        IF (MIN.EQ.MAX) THEN
         IMODE(IB,JB)=MIN
        ELSE
         RANGE=MAX-MIN
         DO 300 I=1,21
          IHIST(I)=0
  300    CONTINUE
         DO 400 J=JPS,JPE
          DO 350 I=IPS,IPE
           ITEM=IFIX(FLOAT(IN(I,J)-MIN)*20.0/RANGE)+1
           IHIST(ITEM)=IHIST(ITEM)+1
  350     CONTINUE
  400    CONTINUE
         IMAX=IHIST(1)
         IVAL=1
         DO 450 I=1,21
          IF (IHIST(I).GE.IMAX) THEN
           IMAX=IHIST(I)
           IVAL=I
           END IF
  450    CONTINUE
         IMODE(IB,JB)=IFIX(FLOAT(IVAL-1)*RANGE/20.0)+MIN
       END IF
  500  CONTINUE
  600 CONTINUE
C
C      NOW INTERPOLATE TO FILL OUT THE FULL ARRAY
C
  700 CONTINUE
      ICEN=(IBOX+1)/2
      W=FLOAT(IBOX)
      DO 1000 JB=1,NBOXJ-1
       DO 900 IB=1,NBOXI-1
        IS=IB*IBOX-ICEN
        JS=JB*IBOX-ICEN
        IF (JB.EQ.(NBOXJ-1)) THEN
         JE=0
             ELSE
         JE=1
             END IF
        DO 850 J=0,IBOX-JE
         G=FLOAT(J)/W
         IF (IB.EQ.(NBOXI-1)) THEN
          IE=0
             ELSE
          IE=1
             END IF
         DO 800 I=0,IBOX-IE
          F=FLOAT(I)/W
          TEM=G*F*IMODE(IB+1,JB+1) + (1.0-G)*F*IMODE(IB+1,JB)
     1        + G*(1.0-F)*IMODE(IB,JB+1)
     2        + (1.0-G)*(1.0-F)*IMODE(IB,JB)
          OUT(IS+I,JS+J)=IFIX(TEM)
  800    CONTINUE
  850   CONTINUE
  900  CONTINUE
 1000 CONTINUE
C
C      NOW TIDY UP THE EDGES
C
      DO 1100 J=1,ICEN-1
       DO 1050 I=1,ICHAN
        OUT(I,J)=OUT(I,ICEN)
 1050  CONTINUE
 1100 CONTINUE
      J1=ICEN+(NBOXJ-1)*IBOX
      DO 1200 J=J1,IXSEC
       DO 1150 I=1,ICHAN
        OUT(I,J)=OUT(I,J1-1)
 1150  CONTINUE
 1200 CONTINUE
      DO 1300 J=1,IXSEC
       I1=ICEN+(NBOXI-1)*IBOX
       DO 1250 I=1,ICEN-1
        OUT(I,J)=OUT(ICEN,J)
 1250  CONTINUE
       DO 1275 I=I1,ICHAN
        OUT(I,J)=OUT(I1-1,J)
 1275  CONTINUE
 1300 CONTINUE
C
C      NOW RETURN WITH THE NEW DATA SAFELY IN "OUT"
C
      RETURN
      END
