      SUBROUTINE XYINCR(ID,X,Y,MAXLEN,LEN,IDENT,ILEVEL,IERR)
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*	TO INTERACTIVELY OBTAIN A SET OF X,Y POSITIONS AND ATTACHED
*	CHARACTER IDENTIFIERS FROM THE ARGS AND INSERT THEM IN
*	A LIST OF POSITIONS
*
*METHOD
*       OBTAIN X,Y POSITION FROM THE ARGS SCREEN USING ASP_PAN AND
*       IDENTIFIER (IF REQUIRED) FROM KEYBOARD USING STARLINK 
*	PARAMETER 'IDENTITY'. 
*	IF THE IDENTIFIER IS BLANK, CREATE ONE USING THE CURRENT
*	COUNT OF BLANK IDENTIFIERS ENTERED. IF THE IDENTIFIER IS IN THE
*	FORM #N, RESET THE BLANK COUNTER TO N. OTHERWISE USE THE
*	IDENTIFIER AS IT STANDS AND ADD IT TO THE LIST.
*	  IF THE LIST IS FULL, CALL XYPRGG TO REMOVE ANY DUPLICATE
*	ENTRIES...IF STILL FULL RETURN. IN ANY CASE
*	CALL XYPRGG BEFORE RETURNING.
*
*ARGUMENTS
*	ID (IN/OUT)
*	BYTE(20,MAXLEN)
*		A LIST OF 20 BYTE ASCII IDENTIFIERS
*	X,Y (IN/OUT)
*	REAL(MAXLEN)
*		LISTS OF X,Y POSITIONS
*	MAXLEN (IN)
*	INTEGER
*		THE MAXIMUM NUMBER OF ENTRIES WHICH CAN BE HELD IN THE
*		LISTS
*	LEN (IN/OUT)
*	INTEGER
*		ON ENTRY, GIVES THE NUMBER OF ENTRIES ALREADY IN THE
*		LISTS ID,X AND Y. ON EXIT, GIVES THE NUMBER OF ENTRIES
*		IN THE OUTPUT LISTS.
*       IDENT (IN)
*       LOGICAL
*               IF TRUE, IDENTIFIERS ARE PROMPTED FOR
*       ILEVEL (IN)
*       INTEGER
*               INTERACTION LEVEL: CONTROLS PRINTING OF POSITIONS ON
*               SCREEN AS THEY ARE OBTAINED
*	IERR (OUT)
*	INTEGER
*		ERROR FLAG: ZERO FOR SUCCESS
*		1: LEN .GT. MAXLEN ON ENTRY
*
*STARLINK PARAMETERS
*       IDENTITY
*               CHARACTER IDENTIFIER FOR POSITIONS
*
*CALLS
*	THIS PACKAGE:
*		LBGONE,XYPRGG
*	STARLINK:
*		RDKEYC,CNPAR,CTOR,WRERR,CTOI
*       ASPIC:
*               ASP_PAN
*
*NOTES
*	USES BYTE ARRAYS
*
*WRITTEN BY
*	R.F. WARREN-SMITH
*-----------------------------------------------------------------------
C
C
      CHARACTER IDBUF*20,INBUF(1)*80,PRBUF*80
      LOGICAL EXIT,IDENT,FINISH
      REAL X(MAXLEN),Y(MAXLEN)
      BYTE ID(20,MAXLEN)
C
C CHECK ARGUMENTS
C
      IF(MAXLEN.LT.LEN) THEN
	IERR=1
      ELSE
	IERR=0
C
C CHECK LENGTH OF LIST IS NOT -VE, INITIALLISE BLANK IDENTIFIER
C COUNT
C
        LEN=MAX(0,LEN)
        NBLANK=1
C
C LOOP WHILE EXIT HAS NOT BEEN SET AND LIST HAS NOT OVERFLOWED
C ------------------------------------------------------------
C
	EXIT=.FALSE.
   67   IF((.NOT.EXIT).AND.(LEN.LE.MAXLEN)) THEN
C
C CALL ASP_PAN TO GET COORDINATES FROM ARGS SCREEN
C
          CALL ASP_PAN(IX,IY,X(LEN+1),Y(LEN+1))
          X(LEN+1)=X(LEN+1)+1.0
          Y(LEN+1)=Y(LEN+1)+1.0
C
C TEST IF USER WANTS TO STOP
C
          FINISH=((X(LEN+1).LE.-1.0).OR.(Y(LEN+1).LE.-1.0))
C
C IF NOT, PRINT POSITION IF REQUIRED
C
          IF(.NOT.FINISH) THEN
            IF(ILEVEL.GE.2) THEN
              WRITE(PRBUF,64) X(LEN+1),Y(LEN+1)
   64         FORMAT('   X=',G13.6,':Y=',G13.6)
              CALL LBGONE(PRBUF(22:))
              CALL LBGONE(PRBUF(15:))
              CALL LBGONE(PRBUF(6:))
              CALL WRUSER(PRBUF,ISTAT)
            ENDIF
C
C IF IDENTIFIER REQUIRED, OBTAIN FROM ENVIRONMENT
C
          INBUF(1)=' '
            IF(IDENT) THEN
	      CALL RDKEYC('IDENTITY',.FALSE.,1,INBUF,NVAL,ISTAT)
              CALL CNPAR('IDENTITY',ISTAT)
              CALL LBGONE(INBUF(1))
            ENDIF
            IDBUF=INBUF(1)
          ENDIF
C
C IF STOPPING, SET EXIT
C
          IF(FINISH) THEN
            EXIT=.TRUE.
          ELSE
C
C TEST IF LIST OF INPUT HAS OVERFLOWED
C
              IF(LEN.GE.MAXLEN) THEN
		EXIT=.TRUE.
	      ELSE
C
C INCREMENT LIST LENGTH IF IT WILL NOT OVERFLOW
C
		LEN=LEN+1
		EXIT=.FALSE.
C
C TREAT THE SPECIAL CASES OF BLANK IDENTIFIER OR '#N'
C ----------------------------------------------------
C
C REMOVE LEADING BLANKS FROM IDENTIFIER AND TEST IF ALL BLANK
C
		CALL LBGONE(IDBUF)
		IF(IDBUF.EQ.' ') THEN
C
C IF BLANK, GENERATE AN IDENTIFIER FROM THE BLANK COUNT IN THE FORM
C '#N' AND INCREMENT THE BLANK COUNT
C
		  WRITE(IDBUF,'(I20)')NBLANK
		  IDBUF(1:1)='#'
	          CALL LBGONE(IDBUF(2:))
		  NBLANK=NBLANK+1
C
C IF ID STARTS WITH # THEN SEE IF IT IS FOLLOWED BY AN INTEGER
C IF SO, RESET NBLANK AND PUT ID IN #N STANDARD FORM
C RESET NBLANK SO THAT SUBSEQUENT BLANK IDENTIFIERS ARE CONVERTED TO
C SEQUENTIALLY NUMBERED '#N' FORM
C
		ELSE IF(IDBUF(1:1).EQ.'#') THEN
		  CALL CTOI(IDBUF(2:),NB,ISTATB)
		  IF(ISTATB.EQ.0) THEN
		    NBLANK=NB+1
		    WRITE(IDBUF,'(I20)')NB
		    IDBUF(1:1)='#'
		    CALL LBGONE(IDBUF(2:))
		  ENDIF
		ENDIF
C
C PUT ID INTO IDENTIFIER LIST
C
		DO 16 I=1,20
		  ID(I,LEN)=ICHAR(IDBUF(I:I))
   16		CONTINUE
	      ENDIF
	    ENDIF
C
C IF LIST IS FULL, CALL XYPRGG TO REMOVE DUPLICATE ENTRIES
C
	    IF(LEN.GE.MAXLEN) THEN
	      CALL XYPRGG(X,Y,ID,LEN,NSAVE,IERR)
	      LEN=NSAVE
	    ENDIF
C
C IF LIST IS STILL FULL, RETURN
C
	    IF(LEN.GE.MAXLEN) THEN
	      EXIT=.TRUE.
	    ENDIF
	    GO TO 67
	  ENDIF
C
C PURGE THE LIST BEFORE LEAVING
C
          IF(LEN.GT.1) THEN
	    CALL XYPRGG(X,Y,ID,LEN,NSAVE,IERR)
	    LEN=NSAVE
	  ENDIF
	ENDIF
	RETURN
	END
