      SUBROUTINE IMGARI
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*	TO PERFORM 4-FUNCTION ARITHMETIC BETWEEN 2 IMAGES
*
*METHOD
*	OBTAIN INPUT IMAGES AND DESCRIPTOR ITEMS. DETERMINE THE
*	FUNCTION REQUIRED. CALL IMGALG TO PERFORM THE ARITHMETIC
*	AND UPDATE THE OUTPUT DESCRIPTOR
*
*ARGUMENTS
*	NONE
*
*STARLINK PARAMETERS
*	AIMAGE
*		THE FIRST INPUT IMAGE
*	BIMAGE
*		THE SECOND INPUT IMAGE
*	WRONGSIZ/ERROR/
*		ACCESSED IF INPUT IMAGES ARE NOT THE SAME SIZE
*	FUNCTION
*		SPECIFIES WHICH ARITHMETIC FUNCTION IS REQUIRED
*	OUTPUT
*		OUTPUT IMAGE
*	TITLE
*		TITLE TO REPLACE INPUT TITLE IN OUTPUT IMAGE
*
*CALLS
*	THIS PACKAGE:
*		GT2DIR,GTDSCR,GETCMD,GT2DIW,IMGALG,PTDSCR
*	STARLINK:
*		WRERR,RDKEYC,CYDSCR,FRDATA
*
*NOTES
*	USES VAX %VAL FACILITY
*
*WRITTEN BY
*	R.F. WARREN-SMITH
*-----------------------------------------------------------------------
C
C
      CHARACTER TITLE(1)*30,CVAL*1,FUN*8
C
C OBTAIN FIRST IMAGE FRAME
C
      CALL GT2DIR('AIMAGE',102,.FALSE.,NPIXA,NLINEA,IPA,IERRA)
      IF(IERRA.EQ.0) THEN
C
C IMAGE OBTAINED SUCCESSFULLY... GET SECOND IMAGE
C
	CALL GT2DIR('BIMAGE',102,.FALSE.,NPIXB,NLINEB,IPB,IERRB)
	IF(IERRB.EQ.0) THEN
C
C SECOND IMAGE OK... CHECK IT IS THE SAME SIZE AS THE FIRST
C IF NOT, GIVE MESSAGE AND ABORT
C
	  IF((NPIXA.NE.NPIXB).OR.(NLINEA.NE.NLINEB)) THEN
	    CALL WRERR('WRONGSIZ')
	    GO TO 99
	  ENDIF
C
C SET DEFAULT DESCRIPTOR ITEM VALUES
C
	  TITLE(1)=' '
	  INVALA=-100000
	  ASCALE=1.0
	  AZERO=0.0
	  INVALB=-100000
	  BSCALE=1.0
	  BZERO=0.0
C
C OBTAIN DESCRIPTOR VALUES
C
	  CALL GTDSCR('AIMAGE','TITLE','CHARACTER',IVAL,RVAL,TITLE(1),
     +    IERR)
	  CALL GTDSCR('AIMAGE','INVAL','INTEGER',INVALA,RVAL,CVAL,IERR)
	  CALL GTDSCR('AIMAGE','BSCALE','REAL',IVAL,ASCALE,CVAL,IERR)
	  CALL GTDSCR('AIMAGE','BZERO','REAL',IVAL,AZERO,CVAL,IERR)
	  CALL GTDSCR('BIMAGE','INVAL','INTEGER',INVALB,RVAL,CVAL,IERR)
	  CALL GTDSCR('BIMAGE','BSCALE','REAL',IVAL,BSCALE,CVAL,IERR)
	  CALL GTDSCR('BIMAGE','BZERO','REAL',IVAL,BZERO,CVAL,IERR)
C
C SET INVALC TO INVALA, OR TO -32767 IF THERE ARE NO INVALID PIXELS
C IN IMAGE A
C
	  IF((INVALA.GE.-32767).AND.(INVALA.LE.32767)) THEN
	    INVALC=INVALA
	  ELSE
	    INVALC=-32767
	  ENDIF
C
C  SET OUTPUT SCALE AND ZERO TO THE A IMAGE VALUES
C
	  CSCALE=ASCALE
	  CZERO=AZERO
C
C DETERMINE THE ARITHMETIC FUNCTION TO BE PERFORMED
C
	  IFUN=1
	  CALL GETCMD('FUNCTION',
     +    'ADD,SUBTRACT,MULTIPLY,DIVIDE,+,-,*,/.',1,IFUN,FUN,LFUN,IERR)
	  IFUN=MOD(IFUN-1,4)+1
C
C OBTAIN OUTPUT IMAGE FRAME
C
	  CALL GT2DIW('OUTPUT',102,.FALSE.,NPIXA,NLINEA,IPOUT,IERROU)
	  IF(IERROU.EQ.0) THEN
C
C OUTPUT FRAME OBTAINED SUCCESSFULLY...CALL IMGALG TO PERFORM THE
C ARITHMETIC
C
	    CALL IMGALG(%VAL(IPA),ASCALE,AZERO,INVALA,
     +      %VAL(IPB),BSCALE,BZERO,INVALB,
     +      NPIXA,NLINEA,IFUN,CSCALE,CZERO,INVALC,%VAL(IPOUT))
C
C OBTAIN OUTPUT TITLE
C
	    CALL RDKEYC('TITLE',.TRUE.,1,TITLE,NVAL,ISTAT)
C
C COPY INPUT DESCRIPTOR TO OUTPUT AND UPDATE ALTERED ITEMS
C
	    CALL CYDSCR('AIMAGE','OUTPUT',ISTAT)
	    CALL PTDSCR('OUTPUT','TITLE','CHARACTER',IVAL,RVAL,TITLE(1),
     +      IERR)
	    CALL PTDSCR('OUTPUT','INVAL','INTEGER',INVALC,RVAL,CVAL,
     +      IERR)
	  ENDIF
	ENDIF
      ENDIF
C
C FREE DATA AREAS AND RETURN
C
   99 CALL FRDATA(' ',ISTAT)
      RETURN
      END
