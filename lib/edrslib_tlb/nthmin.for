      SUBROUTINE NTHMIN(X,NX,N,STAK,IERR)
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*	TO FIND THE N'TH SMALLEST NUMBER IN A SET OF DATA VALUES
*
*METHOD
*	MAINTAIN A STACK OF THE SMALLEST VALUES. COMPARE EACH DATA
*	POINT WITH THE TOP OF STACK.. IF SMALLER, INSERT IT IN THE
*	STACK AT AN APPROPRIATE LEVEL TO MAINTAIN NON-INCREASING
*	STACK ORDER. TOP OF STACK IS LOST WHEN DATA IS INSERTED.
*
*ARGUMENTS
*	X (IN)
*	REAL(NX)
*		ARRAY OF DATA VALUES
*	NX (IN)
*	INTEGER
*		NUMBER OF DATA POINTS
*	N (IN)
*	INTEGER
*		SPECIFIES THE N IN 'NTH SMALLEST DATA VALUE'
*	STAK (OUT)
*	REAL(N)
*		STACK OF N SMALLEST VALUES.. N'TH SMALLEST IN STAK(1)
*	IERR (OUT)
*	INTEGER
*		ERROR FLAG: ZERO FOR SUCCESS
*
*CALLS
*	NONE
*
*WRITTEN BY
*	R.F. WARREN-SMITH
*-----------------------------------------------------------------------
C
C
      REAL X(NX),STAK(N)
      PARAMETER (EXTREM=1.0E20)
C
C CHECK ARGUMENT VALIDITY
C
      IF(N.GT.NX) THEN
	IERR=1
      ELSE
	IERR=0
C
C INITIALLISE THE STACK OF SMALLEST VALUES
C
	DO 1 I=1,N
	  STAK(I)=EXTREM
    1   CONTINUE
C
C COMPARE EACH DATA VALUE WITH THE TOP OF STACK
C
	DO 6 J=1,NX
	  IF(X(J).LT.STAK(1)) THEN
C
C IF LESS THAN TOP OF STACK, IT BELONGS IN THE STACK.. SEARCH DOWN
C THE STACK, MOVING CONTENTS UP.
C
	    DO 2 LOCN=2,N
	      IF(X(J).LT.STAK(LOCN)) THEN
		STAK(LOCN-1)=STAK(LOCN)
	      ELSE
C
C WHEN CORRECT LEVEL IS FOUND, INSERT DATA IN STACK
C
		STAK(LOCN-1)=X(J)
		GO TO 61
	      ENDIF
    2       CONTINUE
C
C ARRIVE HERE IF DATA POINT BELONGS ON BOTTOM OF STACK
C
	    STAK(N)=X(J)
   61       CONTINUE
          ENDIF
    6   CONTINUE
      ENDIF
      RETURN
      END
