      SUBROUTINE XYMTCH(XA,YA,IDA,NA,XB,YB,IDB,NB,
     +                  NMTCH,IERR)
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*	TO SORT 2 LISTS OF X,Y POSITIONS AND IDENTIFIERS SO THAT
*	THE ENTRIES WITH MATCHING IDENTIFIERS OCCUR FIRST IN EACH LIST
*	AND IN THE SAME ORDER
*
*METHOD
*	COMPARE EACH ENTRY IN THE FIRST LIST WITH EACH ENTRY IN THE
*	SECOND. WHEN A MATCH IS FOUND, SWAP THE MATCHING ENTRIES TO THE
*	FRONT OF THE LISTS
*
*ARGUMENTS
*	XA,YA (IN/OUT)
*	REAL(NA)
*		THE FIRST LISTS OF X,Y POSITIONS
*	IDA (IN/OUT)
*	BYTE(20,NA)
*		THE FIRST LIST OF ASCII IDENTIFIERS
*	NA (IN)
*	INTEGER
*		THE NUMBER OF ENTRIES IN THE FIRST LIST
*	XB,YB (IN/OUT)
*	REAL(NB)
*		THE SECOND LIST OF X,Y POSITIONS
*	IDB (IN/OUT)
*	BYTE(20,NB)
*		THE SECOND LIST OF ASCII IDENTIFIERS
*	NB (IN)
*	INTEGER
*		THE NUMBER OF ENTRIES IN THE SECOND LIST
*	NMTCH (OUT)
*	INTEGER
*		THE NUMBER OF MATCHES FOUND
*	IERR (OUT)
*	INTEGER
*		ERROR FLAG: ZERO FOR SUCCESS
*
*CALLS
*	THIS PACKAGE:
*		IABORD,BYTCPY
*
*NOTES
*	USES BYTE ARRAYS
*
*WRITTEN BY
*	R.F. WARREN-SMITH
*-----------------------------------------------------------------------
C
C
      REAL XA(NA),YA(NA),XB(NB),YB(NB),TX,TY
      BYTE IDA(20,NA),IDB(20,NB),TID(20)
      IERR=0
C
C CHECK ARGUMENT VALIDITY
C
      IF(NA.LT.1) THEN
	IERR=1
      ELSE IF(NB.LT.1) THEN
	IERR=2
      ELSE
C
C COUNT THROUGH THE NUMBER OF POSSIBLE ID MATCHES
C
	DO 99 NMTCH=1,MIN(NA,NB)
C
C SCAN THE REMAINING ENTRIES IN LIST A AND COMPARE EACH WITH ALL THE
C REMAINING ENTRIES IN LIST B
C
	  DO 98 LOCA=NMTCH,NA
	    DO 97 LOCB=NMTCH,NB
C
C IF A MATCH IS FOUND, SWAP THE MATCHED ENTRIES WITH THE ENTRY IN
C POSITION NMATCH IN EACH LIST
C
	      IF(IABORD(IDA(1,LOCA),IDB(1,LOCB),20).EQ.0) THEN
		IF(LOCA.NE.NMTCH) THEN
		  TX=XA(LOCA)
		  TY=YA(LOCA)
		  CALL BYTCPY(IDA(1,LOCA),TID(1),20)
		  XA(LOCA)=XA(NMTCH)
		  YA(LOCA)=YA(NMTCH)
		  CALL BYTCPY(IDA(1,NMTCH),IDA(1,LOCA),20)
		  XA(NMTCH)=TX
		  YA(NMTCH)=TY
		  CALL BYTCPY(TID(1),IDA(1,NMTCH),20)
		ENDIF
		IF(LOCB.NE.NMTCH) THEN
		  TX=XB(LOCB)
		  TY=YB(LOCB)
		  CALL BYTCPY(IDB(1,LOCB),TID(1),20)
		  XB(LOCB)=XB(NMTCH)
		  YB(LOCB)=YB(NMTCH)
		  CALL BYTCPY(IDB(1,NMTCH),IDB(1,LOCB),20)
		  XB(NMTCH)=TX
		  YB(NMTCH)=TY
		  CALL BYTCPY(TID(1),IDB(1,NMTCH),20)
		ENDIF
C
C AFTER A MATCH HAS BEEN FOUND, EXIT LOOP AND GO TO NEXT POSSIBLE
C MATCH
C
		GO TO 99
	      ENDIF
   97 	    CONTINUE
   98     CONTINUE
C
C EMERGE HERE IF NO MATCH WAS FOUND.. SO EXIT
C
          GO TO 100
   99   CONTINUE
C
C SET THE NUMBER OF MATCHES ACTUALLY FOUND
C
  100   NMTCH=NMTCH-1
      ENDIF
      RETURN
      END
