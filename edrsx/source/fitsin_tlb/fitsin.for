*+  FITSIN - Reads a FITS tape into a series of NDFs

      SUBROUTINE FITSIN( STATUS )
*
*    Description :
*
*     This routine reads selected files off a simple or a random-groups-
*     format FITS magnetic tape (Wells et al. 1981, Greisen and Harten
*     1981) and, writes the data into HDS files in the NDF format
*     (though any axis information is not stored in an AXIS structure.)
*     Currently, this application cannot deal with the recent extensions
*     to FITS (Harten et al. 1988; Grosbol et al. 1988), but it does
*     process tapes containing blocked FITS records, provided the
*     blocking factor does not exceed the 1987 Jan 1 rules, viz. ten.
*
*     A record of the FITS headers, and group parameters (for a
*     group-format file) may be stored in an ASCII file.
*
*     The tape must be mounted prior to use of this application.  In
*     ICL use the command MOUNT.
*
*     There is an option to run in automatic mode, where the names of
*     output NDF data structures are generated automatically, and the
*     user can decide whether or not format conversion is to be applied
*     to all files (rather than being prompted for each). This is very
*     useful if there are a large number of files to be processed.  Even
*     if you want unique file names, format-conversion may be switched
*     off globally.
*
*     The user specifies the numbers of the files to be read from the
*     tape and processed.  These are numbered consecutively from 1.
*     Single files or a set of adjacent files may be specified, e.g.
*     [4,6-9,12,14-16] will read files 4,6,7,8,9,12,14,15,16. (Note
*     that the brackets are required to distinguish this array of
*     characters from a single string including commas.) For
*     efficiency reasons it is sensible to give the file numbers in
*     ascending order. Once a list of files has been processed, further
*     lists of files may be specified.
*
*     For each file:
*
*     1. The FITS descriptors are reported to the user, who is then
*        asked whether data conversion is to take place or not, (unless
*        the global no-conversion switch is set or the application is in
*        automatic mode.)  If not, the HDS type of the data array in the
*        NDF will be the equivalent of the data format on tape (e.g.
*        BITPIX = 4 creates a _WORD array).  If data conversion is
*        requested, a _REAL data array is created, and the values of the
*        FITS descriptors BSCALE and BZERO are applied to the tape data
*        to generate the "true" data values. If BSCALE and BZERO are not
*        given in the FITS header, they are taken to be 1.0 and 0.0
*        respectively. If the BLANK item is present in the header,
*        undefined pixels are converted from the BLANK value to
*        Starlink-standard magic value during data conversion.
*
*     2. Next the user is prompted for the name of the output HDS
*        container file, again unless the automatic mode is operative.
*        A null response may be given so that no file is created.  Thus
*        the user can review descriptors before deciding whether or not
*        the data are to be extracted.
*
*        In automatic mode the application generates a filename
*        beginning with a defined prefix followed by the number of the
*        file on tape.  For example, if the prefix was 'XRAY' and the
*        25th file of the tape was being processed, the filename of the
*        NDF would be XRAY25.
*
*        For groups format, a new NDF is created for each data array. 
*        The name of the NDF of the second and subsequent data arrays is
*        generated by the application as the filenameGnumber, where
*        filename is the name of the first NDF, supplied by the user or
*        generated automatically, and number is the number of the group.
*
*     3. If there is no data array on tape, i.e. the FITS file comprises
*        header cards only, then a dummy vector data array of dimension
*        two is created to make the output a valid NDF.  This data array
*        is undefined.
*
*     References:  Wells, D.C., Greisen, E.W. & Harten, R.H. 1981,
*                     Astron. Astrophys. Suppl. Ser. 44, 363.
*                  Greisen, E.W. & Harten, R.H. 1981,
*                     Astron. Astrophys. Suppl. Ser. 44, 371.
*                  Grosbol, P., Harten, R.H., Greisen, E.W & Wells, D.C.
*                     1988 Astron. Astrophys. Suppl. Ser. 73, 359.
*                  Harten, R.H., Grosbol, P., Greisen, E.W & Wells, D.C.
*                     1988 Astron. Astrophys. Suppl. Ser. 73, 365.
*
*    Invocation :
*
*     CALL FITSIN( STATUS )
*
*    Parameters :
*
*     LOGHDR = LOGICAL( READ )
*         If true a log of the header records is written to an ASCII
*           file.
*     LOGFILE = CHAR( READ )
*         The file name of the log of the FITS header cards
*     MTDECK = DEVICE( READ )
*         Tape deck containing the data, usually an explicit device,
*           though it can be a pre-assigned logical name.
*     LABEL  = LOGICAL( READ )
*         True if the tape has labelled files
*     AUTO = LOGICAL( READ )
*         True if automatic mode is required, where the name of each
*           output NDF structure is to be generated by the application,
*           and therefore not prompted; and a global format-conversion
*           switch may be set
*     PREFIX = CHAR( READ )
*         If %AUTO is true this is the prefix of the NDF's file name
*     NOCON  = LOGICAL( READ )
*         True if no format conversions are required for any data array,
*           otherwise a format-conversion query will occur for each FITS
*           file. It is ignored in automatic mode --- in effect it 
*           becomes false
*     FILES  = CHAR( READ )
*         List of the file numbers to be processed
*     FMTCNV = LOGICAL( READ )
*         If true the data array in the current file will be converted
*           from the data type on tape to _REAL, and in automatic mode
*           all files will be converted
*     OUTPUT = NDF( WRITE )
*         Output NDF structure holding the full contents of the FITS
*           file
*     MORE   = LOGICAL( READ )
*         A prompt asking if any more files are to be processed
*
*    Arguments:
*
*     STATUS = INTEGER( READ, WRITE )
*         Global status value
*
*    Method :
*
*     Check for error on entry - return if not o.k.
*     See whether or not a log file is required
*     If logging then
*        Initialise looping flag
*        Do while no error obtaining the name and opening the output
*          file
*           and maximum number of attempts not exceeded
*           Get file name and open file
*           If error occurred then
*              If abort requested do so
*              Increment loop counter
*              If maximum number of attempts not exceeded then
*                 Report error
*              Else
*                 Set looping flag to exit
*              Endif
*              Cancel parameter used to get filename
*           Else
*              Set looping flag to false
*           Endif
*        Enddo
*        If error then
*           Report and abort
*        Endif
*     Endif
*     Get the tape device.
*     If there is an error report it and retry
*     If maximum number of retries exceeded, report error and abort
*     Rewind the tape
*     If there is an error, report it and abort
*     Ask if the tape is labelled (this affects tape positioning)
*     Determine whether or not automatic operation is required
*     If so then
*        Prevent prompting for the the format conversion for each file
*        Determine whether or not all data arrays are to undergo format
*          conversion
*        Get the prefix for the output NDFs and its length
*     Else
*        Determine whether or not format-conversion option is available
*          for each data array
*     Endif
*     Until no more files to be extracted and no error
*        Read list of files to be processed
*        If a null response was given then
*           Report error
*        Else
*           For each file specification
*              Calculate file limits
*              If there is an error parsing list of files then
*                 Report error
*              Else
*                 For each file in the current specification
*                    Move to the appropriate file
*                    If an error occurred, report it, tidy and abort
*                    Initialise flags to say there is a data array
*                      and it is standard
*                    Read a block from the tape into a buffer
*                    If an error occurred, report it, tidy and abort
*                    Check block size conforms to the FITS rules
*                    If not report error and go onto the next file
*                    Create a dummy file to store the header cards
*                      dynamically and store in a fixed-size header
*                      (dynamic version that gets the headers from
*                      the dummy file is much less efficient, but the
*                      code still exists)
*                    If there is an error report it, tidy and abort
*                    Display current file number to reassure user
*                    Store the header information in the work file
*                    Abort if an error occurred
*                    Call routine to check that mandatory descriptors
*                      are present, reporting an error if they any are
*                      missing, and get their values, again reporting
*                      an error if the value is not a FITS standard;
*                      find out whether or not there is a data array,
*                      and if the file contains random-group data; and
*                      get the number of pixels in the/each data array
*                    If the tape is not FITS, or is in an unsupported
*                      format report that processing will go to the
*                      next file if there is one
*                    If there is a data array then
*                       If the data are integers then
*                          Get the value of BSCALE and BZERO descriptors
*                            defaulting to 1.0 and 0.0 if not present
*                          Get the value of BLANK descriptor
*                          If the data array is non-standard then
*                             Get the value of GROUPS
*                             If GROUPS is not present or false then
*                                Report error and go to the next file
*                             Endif
*                             Get the group and parameter counts, and
*                               the parameter types from the header
*                             Report an error if descriptor is not
*                               present and go ot the next file
*                             Get the scales and offsets of the
*                               group parameters, setting them to 1.0
*                               and 0.0 respectively if they are missing
*                             Shift the dimensions if the first is a
*                               dummy to indicate group format
*                          Else
*                             Set group count to 1 and parameter count
*                               to 0.
*                          Endif
*                       Else
*                          To be a valid NDF it must have a DATA_ARRAY
*                            so create some dummy dimensions
*                          Set group count to 1 and parameter count
*                            to 0.
*                       Endif
*                       If there is a logfile write caption and header
*                         cards to it
*                       If there was an error, report context, tidy and
*                         abort
*                       If there is to be a format-conversion option
*                         for each file then
*                          Inquire whether or not to override the
*                            standard data TYPE to create a _REAL data
*                            array
*                       Endif
*                       Assign the bits-per-pixel and input format code
*                       If format conversion required then
*                          Set output format
*                       Else
*                          Output format is input format
*                       Endif
*                       If automatic mode then
*                         Generate the NDF file name or (prefix if
*                           group-format file) and its length
*                       Endif
*                       For each data array
*                          If it is the first array and automatic
*                              operation is not in effect then
*                             Create the container file obtaining its
*                               name from the parameter system
*                             Get locator for first input structure
*                             If a null response given then
*                                Report that no file is being created
*                                Move on to the next file
*                             Endif
*                          Else
*                             If groups format then
*                                Generate file name for the group data
*                                  array
*                             Else
*                                Use the automatically generated file
*                                  name
*                             Endif
*                             Create the container file obtaining its
*                               name from the application and get
*                               locator to it
*                          Endif
*                          If an error occurred then
*                             Report error and abort
*                          Else
*                             Create top-level objects and MORE.FITS
*                             If an error occurred, report it and abort
*                          Endif
*                          If format conversion then
*                             Create a work array for the input data
*                               and map it
*                             If an error occurred, report it and abort
*                             Map the data array
*                             If an error occurred, report it and abort
*                             Select appropriate pointer for the input
*                               data
*                             If non-standard array then
*                                Read the data into the data array, and
*                                  read the associated parameters
*                                Tidy up after an error and go to the
*                                  next file
*                                Enlarge the structure containing the
*                                  FITS header cards
*                                Report an error, tidy and abort
*                                Move the last (END) card to the last
*                                  element of the dummy structure
*                                For each parameter
*                                   Apply scale and offset to get true
*                                     value
*                                   Create pseudo-FITS card
*                                   Write card to dummy structure
*                                     after last card (and before END
*                                     card)
*                                   If an error occurred, report
*                                     context, tidy and abort
*                                Endfor
*                                If there is logging then
*                                   Write group parameters to the
*                                     logfile
*                                Endif
*                             Else
*                                Read the data into the data array
*                                  directly
*                                If there was an error, tidy and go to
*                                  the next file
*                             Endif
*                             If there is to be format conversion then
*                                Convert work array (which contains
*                                  input data) to the REAL data array
*                                Tidy workspace
*                                Apply scale and offset to get true
*                                  value, and set undefined pixels to
*                                  the magic value
*                             Endif
*                             Unmap data array
*                          Endif
*                          Copy dummy header to MORE.FITS structure
*                          If an error occurred, report context, tidy
*                            and abort
*                          Tidy locators
*                          If there are group arrays, and the first
*                            array has just been processed, and
*                            automatic mode is not operative then
*                             Get the filename of the NDF created for
*                               the first data array in the file
*                             If an error occurred, report context
*                               and go to the next file
*                          Endif
*                          Report progress of group-data processing
*                          If the NDF file name was obtained from the
*                            parameter system cancel the association
*                       Endfor
*                    Endfor
*                 Endfor
*              Endif
*           Endfor
*        Endif
*        See whether or not more files are to be read
*     Endfor
*     If aborted then tidy data-structure locators
*     Annul tape device
*     Close the logfile if there is one
*     End
*
*    Bugs :
*
*     None known.
*
*    Authors :
*
*     Malcolm J. Currie, RAL( UK.AC.RL.STAR::CUR )
*     Peter Allan, University of Manchester ( MAVAD::PMA )
*
*    History :
*
*     1987 Jul  8 : Uses HDS but not the NDF format as it was not then
*                   defined. ( MAVAD::PMA )
*     1988 Mar 25 : Second version. Modified to use FITS extension to
*                   standard NDF format. ( MAVAD::PMA )
*     1988 Apr 19 : Allow a null parameter for the output dataset, which
*                   skips the processing of that file. This allows the
*                   user to read the fits header and to then decide not
*                   to create an output file.
*     1988 May    : Converted to KAPPA style, added further error
*                   checks and aborts, removed references to the Interim
*                   environment ( RL.STAR::CUR )
*     1988 Sept   : Greatly expanded and rewritten to process group-
*                   format files and blocked records ( RL.STAR::CUR ).
*     1988 Nov  2 : Corrected some of the tidying, particularly
*                   cancelling OUTPUT, annulling FLOC and fixing an
*                   editing typo' unmapping and annulling of the work
*                   array ( RL.STAR::CUR ).
*     1988 Nov  3 : Added automatic mode, no data-conversion option
*                   and more commentary as each file is processed
*                   ( RL.STAR::CUR ).
*     1988 Nov  4 : Close HDS files created by HDS_NEW to prevent lots
*                   of files being open ( RL.STAR::CUR )
*
*    Type definitions :

      IMPLICIT  NONE           ! no default typing allowed

*    Global constants :

      INCLUDE  'SAE_PAR'       ! SSE global definitions
      INCLUDE  'DAT_ERR'       ! Data-system errors
      INCLUDE  'MAG_ERR'       ! MAG-error definitions
      INCLUDE  'PAR_ERR'       ! Parameter-system errors

*    Status :

      INTEGER  STATUS

*    External references :

      INTEGER
     :  CHR_LEN

*    Local Constants :

      INTEGER
     :  BLKSIZ,                ! maximum blocksize, which is the FITS
                               ! record length, times the maximum
                               ! blocking factor of ten
     :  BUFSIZ,                ! Size of buffer to store header cards
     :  MXCARD,                ! maximum number of card images
     :  MXFILE,                ! Maximum size of input file list
     :  MXLOOP,                ! Maximum number of attempts at obtaining
                               ! tape deck
     :  MXPARM,                ! Maximum number of parameters that can
                               ! be associated with a group-format array
     :  MXAXIS,                ! Maximum number of axes
     :  LWORD,                 ! STL_FMTCON type code for INTEGER data
     :  REAL,                  ! STL_FMTCON type code for REAL data
     :  UBYTE,                 ! STL_FMTCON type code for BYTE data
     :  WORD                   ! STL_FMTCON type code for WORD data
      PARAMETER(
     :  BLKSIZ = 28800,
     :  BUFSIZ = BLKSIZ / 8,
     :  MXCARD = BLKSIZ / 80,
     :  MXFILE = 32,
     :  MXLOOP = 4,
     :  MXPARM = 999,
     :  MXAXIS = DAT__MXDIM,
     :  LWORD = 3,
     :  REAL = 4,
     :  UBYTE = 6,
     :  WORD = 2 )

*    Local variables :

      INTEGER
     :  ACTSIZ,                ! Actual size of a tape block
     :  BITPIX,                ! Number of bits per pixel
     :  BLANK,                 ! Tape data value assigned to undefined-
                               ! value pixels
     :  BPV,                   ! Number of bytes per pixel
     :  BF,                    ! number of complete FITS records per
                               ! tape block
     :  CARD,                  ! Record number in a header
     :  DAPNTR,                ! Pointer to data array
     :  DIMS( MXAXIS ),        ! The size of each axis
     :  FIRST,                 ! First tape file in a sequence
     :  FD,                    ! file description
     :  FN,                    ! File number of the tape
     :  FORMIN,                ! Format of data on tape
     :  FS,                    ! File sequence
     :  GCOUNT,                ! Number of groups contained in the file
     :  HDNUM,                 ! Header number
     :  IMCODE,                ! ADAM pointer to OUTPUT parameter
     :  LAST,                  ! Last tape file in a sequence
     :  LOOP                   ! Number of failures to obtain tape deck

      INTEGER
     :  MT,                    ! Tape descriptor
     :  I, N,                  ! Loop counters
     :  NBAD,                  ! Number of bad conversions found by 
                               ! STL_FMTCON
     :  NCFILN,                ! Number of characters in file number
     :  NCH,                   ! Number of characters returned by
                               ! CHR_ITOC
     :  NCPREF,                ! Number of characters in file prefix
     :  NCROOT,                ! Number of characters in file root name
     :  NDIM,                  ! Number of dimensions in the FITS image
     :  NFSPEC,                ! Number of file sequences to be
                               ! processed
     :  OFFSET,                ! The number of bytes of the current tape
                               ! block that contains processed
                               ! information (zero means the block has
                               ! been fully processed)
     :  OPENST,                ! file open status
     :  PARAMS( MXPARM ),      ! Numerical values of parameters 
                               ! associated with a group-format array
     :  PCOUNT,                ! The number of parameter values
                               ! preceeding each data array
     :  PNTR,                  ! Pointer to array used by data-reading 
                               ! subroutines
     :  SIZE,                  ! Total size of the data array
     :  WKPNTR                 ! Pointer to work array

      LOGICAL                  ! True if:
     :  ASSOC,                 ! Name of the current NDF obtained by
                               ! parameter system (i.e. first group and
                               ! not automatic mode)
     :  AUTO,                  ! Automatic mode is operative
     :  BADPIX,                ! Data array has undefined pixels
     :  DARRAY,                ! There is a data array in the FITS file
     :  DAMAP,                 ! Data array is mapped
     :  DECK,                  ! Tape deck obtained successfully
     :  FMTCNV,                ! The type of the data on tape will be
                               ! converted to real in the output data
                               ! structure
     :  GROUPS,                ! Data structure has groups format
     :  LABEL,                 ! The tape is labelled
     :  LOGHDR,                ! A log of the header is written to an
                               ! ASCII file
     :  LOOPAG,                ! Loop again to open output file
     :  MORE,                  ! More files are to be read
     :  NOCON,                 ! No prompting for the format conversion
                               ! of each file
     :  NONSDA,                ! There is a non-standard data array in
                               ! the FITS file
     :  THERE,                 ! A specified descriptor is present in
                               ! the FITS header
     :  WKMAP                  ! Work data are mapped

      REAL
     :  BSCALE,                ! Scale factor used to convert tape
                               ! values to true values
     :  BZERO                  ! Offset applied to true pixel values

      DOUBLE PRECISION
     :  PSCALE( MXPARM ),      ! Scale factor used to convert tape
                               ! parameter values to true values
     :  PZERO( MXPARM ),       ! Offset applied to true parameter values
     :  TPARAM                 ! True parameter value

      CHARACTER*16
     :  FILES( 32 ),           ! File numbers
     :  FORMTI*(DAT__SZTYP),   ! Format of input data array
     :  FORMAT*(DAT__SZTYP),   ! Format of output data array
     :  PAVAL*20,              ! I20 format of a parameter value
     :  PNUM*4,                ! Number of group-format parameter
     :  PTYPE( MXPARM )        ! Parameter names for groups format

      CHARACTER*80
     :  BUFFER( MXCARD ),      ! Buffer for a FITS header block
     :  DUMMY,                 ! Buffer for output of labels to logfile
     :  FILNAM,                ! Name of HDS container file for groups
                               ! format
     :  FILNO*6,               ! Number of HDS container file for
                               ! groups format
     :  FILROO,                ! Root name of HDS container file for
                               ! groups format and automatic mode
     :  HEADER( BUFSIZ ),      ! Header card images (fixed-size
                               ! preferred to HDS work for access of
                               ! the header cards for efficiency reason)
     :  PACARD,                ! Group-format parameter in card form
                               ! (with integer value)
     :  PREFIX                 ! Prefix for automatic generation of NDF
                               ! file names

      CHARACTER*(DAT__SZLOC)   ! locators for :
     :  FLOC,                  !   MORE.FITS structure
     :  HD1LOC,                !   individual header records
     :  MLOC,                  !   MORE structure
     :  LOC,                   !   output NDF structure
     :  TLOC,                  !   temporary header
     :  WKLOC                  !   workspace for data conversion

*-
*    Check status on entry - return if not o.k.

      IF ( STATUS .NE. SAI__OK ) RETURN

*    Is a log of the headers required?

      LOGHDR = .FALSE.
      CALL AIF_GTDLG( 'LOGHDR', .FALSE., LOGHDR, STATUS )
      CALL PAR_CANCL( 'LOGHDR', STATUS )

      IF ( LOGHDR ) THEN
         LOOP = 0
         LOOPAG = .TRUE.
         DO WHILE ( LOOPAG )

*          Attempt to obtain and open a file to output listing

            CALL FIO_ASSOC( 'LOGFILE', 'WRITE', 'LIST', 80, FD, STATUS )

            IF ( STATUS .NE. SAI__OK ) THEN
               IF ( STATUS .EQ. PAR__ABORT ) GOTO 999

*            Here if filename is not allowed or file is not opened
*            - try again
*            Need to flush error here, as not quitting routine

               LOOP = LOOP + 1
               IF ( LOOP .LE. MXLOOP ) THEN
                  CALL ERR_OUT( 'ERR_FITSIN_NOFI',
     :              'FITSIN : Could not open file $LOGFILE - try again',
     :              STATUS )
               ELSE

*                end looping as user is having serious problems

                  LOOPAG = .FALSE.
               END IF

               CALL PAR_CANCL( 'LOGFILE', STATUS )

            ELSE

               CALL MSG_OUT( 'LOG', 'Logging to $LOGFILE', STATUS )

*             no problem, so exit loop

               LOOPAG = .FALSE.

*          end of file-opened-successfully check

            END IF
         END DO

*       abort for repeated error

         IF ( STATUS .NE. SAI__OK ) THEN
            CALL ERR_REP( 'ERR_FITSIN_NOOPEN',
     :        'FITSIN: Repeatedly unable to open a file. Aborting',
     :        STATUS )
            GOTO 999
         END IF

      END IF


*    Get tape input device

      LOOP = 0
      DECK = .FALSE.
      DO WHILE( .NOT. DECK )
         CALL MAG_ASSOC( 'MTDECK', 'READ', MT, STATUS )

         IF ( STATUS .NE. SAI__OK ) THEN
            IF ( STATUS .EQ. PAR__ABORT ) GOTO 990

*          here if tape deck not found - try again
*          need to flush error here, as not quitting routine

            LOOP = LOOP + 1
            IF ( LOOP .LT. MXLOOP ) THEN
               CALL ERR_OUT( 'ERR_FITSIN_ASSOC',
     :           'FITSIN: Error obtaining tape deck.', STATUS )
            ELSE

*             end looping as user is having serious problems

               DECK = .TRUE.
            END IF

            CALL PAR_CANCL( 'MTDECK', STATUS )
         ELSE

*          no problem, so exit loop

            DECK = .TRUE.

*       end of deck-assigned-successfully check

         END IF
      END DO

      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'ERR_FITSIN_NODECK',
     :     'FITSIN: Repeatedly failed to obtain tape deck', STATUS )
         GOTO 990
      END IF

*    Rewind the tape

      CALL MAG_REW( MT, STATUS )

      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'ERR_FITSIN_REW',
     :     'FITSIN: Unable to rewind the tape --- the tape may not '/
     :     /'be mounted', STATUS )
         GOTO 980
      END IF

*    Check if tape is labelled

      CALL PAR_GET0L( 'LABEL', LABEL, STATUS )
      CALL PAR_CANCL( 'LABEL', STATUS )

*    Is automatic mode required

      AUTO = .FALSE.
      CALL AIF_GTDLG( 'AUTO', .FALSE., AUTO, STATUS )

      IF ( AUTO ) THEN

*       Set no prompting for the format conversion of each file

         NOCON = .TRUE.

*       Determine whether or not format conversion is to be applied to
*       all the files to be read

         CALL AIF_GTDLG( 'FMTCNV', .FALSE., FMTCNV, STATUS )

*       Get the prefix for the NDF file names and its length

         CALL PAR_GET0C( 'PREFIX', PREFIX, STATUS )
         NCPREF = CHR_LEN( PREFIX )

      ELSE

*       No format conversion?

         NOCON = .FALSE.
         CALL AIF_GTDLG( 'NOCON', .FALSE., NOCON, STATUS )
      END IF

*    Get file list and check number of specifications

      MORE = .TRUE.
      DO WHILE( MORE .AND. STATUS .EQ. SAI__OK )
         CALL PAR_GET1C( 'FILES', MXFILE, FILES, NFSPEC, STATUS )

*       Abort if requested

         IF ( STATUS .EQ. PAR__ABORT ) THEN
            GOTO 980
         END IF

*       Check for null response

         IF ( NFSPEC .EQ. 0 .OR. STATUS .EQ. PAR__NULL ) THEN
            CALL ERR_OUT( 'ERR_FITSIN_NOFILES',
     :        'FITSIN: No files were specified', STATUS )
            IF ( NFSPEC .EQ. 0 ) STATUS = SAI__ERROR
            CALL PAR_CANCL( 'FILES', STATUS )
         ELSE

*          Scan through tape, processing each file specification

            DO FS = 1, NFSPEC

*             Calculate file-limits

               CALL CFILIM( FILES( FS ), FIRST, LAST, STATUS )

*             Check file specification

               IF ( STATUS .NE. SAI__OK ) THEN
                  CALL ERR_OUT( 'ERR_FITSIN_BADSPEC',
     :              'FITSIN: Error in file specification', STATUS )
               ELSE


*                Process each file in this specification

                  DO FN = FIRST, LAST

*                   Move to the appropriate file

                     IF ( LABEL ) THEN
                        CALL MAG_MOVE( MT, 3*FN-2, .TRUE., 1, STATUS )
                     ELSE
                        CALL MAG_MOVE( MT, FN, .TRUE., 1, STATUS )
                     END IF

*                   Report error context

                     IF ( STATUS .NE. SAI__OK ) THEN
                        CALL MSG_SETI( 'FN', FN )
                        CALL ERR_REP( 'ERR_FITSIN_MOVE',
     :                    'FITSIN: Error positioning tape at file ^FN',
     :                    STATUS )
                        GOTO 980
                     END IF

*                   Assume for the moment that there will a data array
*                   in the FITS header, and it is in a standard format

                     DARRAY = .TRUE.
                     NONSDA = .FALSE.

*                   Read first header record and check for error

                     CALL MAG_READ( MT, BLKSIZ, %REF( BUFFER ), ACTSIZ,
     :                              STATUS )
                     IF ( STATUS .NE. SAI__OK ) THEN
                        CALL ERR_OUT( 'ERR_FITSIN_HDREAD',
     :                    'FITSIN: Error while reading the first '/
     :                    /'record of the file', STATUS )
                        GOTO 960
                     END IF

*                   Blocking factor must be an integer factor from one
*                   to ten of the standard FITS record. Note the buffer
*                   is larger to store the whole of the header

                     BF = ACTSIZ / 2880
                     IF ( MOD( ACTSIZ, 2880 ) .NE. 0 .OR.
     :                    BF .GT. 10 .OR. BF .LT. 1 ) THEN
                        CALL ERR_OUT( 'ERR_FITSIN_IBLOCK',
     :                    'FITSIN: Tape has illegal-length blocks. '/
     :                    /'Blocks must be a multiple (1--10) of the '/
     :                    /'FITS record length of 2880 bytes', STATUS )
                        GOTO 960
                     END IF

*                   Create a dummy header structure

                     CALL DAT_TEMP( '_CHAR*80', 1, 100, TLOC, STATUS )
                     IF ( STATUS .NE. SAI__OK ) THEN
                        CALL ERR_REP( 'ERR_FITSIN_HDS',
     :                    'FITSIN: Error creating a dummy header '/
     :                    /'structure', STATUS )
                        GOTO 980
                     END IF

                     IF ( .NOT. AUTO ) THEN

*                      Display file number

                        CALL MSG_SETI( 'FN', FN )
                        CALL MSG_OUT( 'FILEHEAD',
     :                    'File # ^FN  Descriptors follow:', STATUS )
                     END IF

*                   Process the header blocks

                     CALL FITSPH( MT, TLOC, BLKSIZ, .NOT. AUTO, BUFFER,
     :                            ACTSIZ, OFFSET, HEADER, HDNUM,
     :                            STATUS )

                     IF ( STATUS .NE. SAI__OK ) THEN
                        CALL DAT_ANNUL( TLOC, STATUS )
                        GOTO 980
                     END IF

*                   Now the complete header is stored in the buffer.
*                   The values of certain items stored in the buffer
*                   are required to generate the data array.
*                   This is not the most efficient method to obtain
*                   selected descriptor values, but, in the main, the
*                   important descriptors will be in the early cards.
*                   (However, using the HEADER buffer is much more
*                   efficient than repeatedly accessing the work file
*                   to obtain header information.) Efficiency has been
*                   sacrificed for more-structured and flexible code.

*                   Check that mandatory descriptors are present

                     CALL FITSMH( HEADER, BITPIX, NDIM, DIMS,
     :                            DARRAY, NONSDA, SIZE, STATUS )

*                   Check for an error, because file is not in FITS
*                   format, or has an unsupported FITS extension

                     IF ( STATUS .NE. SAI__OK ) THEN

*                      Now report error context and future action

*                      Error occurred on last file
                                                                    
                        IF ( FN .EQ. LAST .AND. FS .EQ. NFSPEC ) THEN
                           CALL ERR_OUT( 'ERR_FITSIN_IVHEADL',
     :                       'FITSIN: Unable to read the last file.',
     :                       STATUS )
                        ELSE

                           CALL ERR_OUT( 'ERR_FITSIN_IVHEAD',
     :                       'FITSIN: Unable to read the current '/
     :                       /'file. Going to next file', STATUS )
                        END IF

                        CALL DAT_ANNUL( TLOC, STATUS )
                        GOTO 960
                     END IF

*                   If there is a data array

                     IF ( DARRAY ) THEN

*                      If data are integers

                        IF ( BITPIX .GT. 0 ) THEN

*                         First get the BSCALE

                           CALL FITSGR( HEADER, 'BSCALE', THERE, BSCALE,
     :                                  STATUS )
                           IF ( .NOT. THERE ) BSCALE = 1.0

*                         Next the BZERO

                           CALL FITSGR( HEADER, 'BZERO', THERE, BZERO,
     :                                  STATUS )
                           IF ( .NOT. THERE ) BZERO = 0.0
                        END IF

*                      Now the undefined pixel value, BLANK

                        CALL FITSGI( HEADER, 'BLANK', BADPIX, BLANK,
     :                               STATUS )

*                      If data array is non-standard it must be have the
*                      groups format to be processed


                        IF ( NONSDA ) THEN
                           CALL FITSGL( HEADER, 'GROUPS', THERE, GROUPS,
     :                                  STATUS )
                           IF ( .NOT. GROUPS .OR. .NOT. THERE ) THEN
                              CALL ERR_OUT( 'ERR_FITSIN_NOBLO',
     :                          'FITSIN: The only supported '/
     :                          /'non-standard data array is the '/
     :                          /'blocks (random-group) format.',
     :                          STATUS )

                              CALL DAT_ANNUL( TLOC, STATUS )
                              GOTO 960
                           END IF

*                         Now look for the group and parameter counts

                           CALL FITSGI( HEADER, 'GCOUNT', THERE, GCOUNT,
     :                                  STATUS )
                           IF ( .NOT. THERE ) GCOUNT = 1

                           CALL FITSGI( HEADER, 'PCOUNT', THERE, PCOUNT,
     :                                  STATUS )
                           IF ( .NOT. THERE ) THEN
                              CALL ERR_OUT( 'ERR_FITSIN_PCOUNT',
     :                          'FITSIN: PCOUNT not defined', STATUS )

                              CALL DAT_ANNUL( TLOC, STATUS )
                              GOTO 960
                           END IF

                           DO  N = 1, PCOUNT
                              CALL CHR_ITOC( N, PNUM, NCH )
                              CALL FITSGC( HEADER, 'PTYPE'//PNUM, THERE,
     :                                     PTYPE( N ), STATUS )
                              IF ( .NOT. THERE ) THEN
                                 CALL MSG_SETI( 'N', N )
                                 CALL ERR_OUT( 'ERR_FITSIN_PTYPEn',
     :                             'FITSIN: PTYPE^N not present',
     :                             STATUS )
                                 CALL DAT_ANNUL( TLOC, STATUS )
                                 GOTO 960
                              END IF

*                            Get scale and zero, using double precision
*                            to avoid loss of precision, though it may
*                            create a false precision in the output dat
*                            structure.  Routine FITSG needs to be
*                            designed such that the number of
*                            significant figures is returned and FITSIN
*                            can format the results accordingly.

                              CALL FITSGD( HEADER, 'PSCAL'//PNUM,
     :                                     THERE, PSCALE( N ), STATUS )
                              IF ( .NOT. THERE ) PSCALE( N ) = 1.0

                              CALL FITSGD( HEADER, 'PZERO'//PNUM,
     :                                     THERE, PZERO( N ), STATUS )
                              IF ( .NOT. THERE ) PZERO( N ) = 0.0
                           END DO

*                         Shift dimensions, if first is dummy

                           IF ( DIMS( 1 ) .EQ. 0 ) THEN
                              NDIM = NDIM - 1
                              DO  N = 1, NDIM
                                 DIMS( N ) = DIMS ( N + 1 )
                              END DO
                           END IF

*                      Standard format, so a there is a single data
*                      array

                        ELSE
                           GCOUNT = 1
                           PCOUNT = 0
                    
                        END IF

                     ELSE

*                      To be a valid NDF, it must have a DATA_ARRAY 
*                      component so create some dummy dimensions...

                        NDIM = 1
                        DIMS( 1 ) = 2

*                      so a there is now a single data array

                        GCOUNT = 1
                        PCOUNT = 0

*                   End of data-array(s)-present check

                     END IF

*                   Write header to log if required.  

                     IF ( LOGHDR ) THEN
                        DUMMY = ' '
                        CALL FIO_WRITE( FD, DUMMY, STATUS )
                        WRITE( DUMMY, '(''** File number:'',I6,
     :                         '' header cards'')' ) FN
                        CALL FIO_WRITE( FD, DUMMY, STATUS )

                        DO  I = 1, HDNUM
                           CALL FIO_WRITE( FD, HEADER( I ), STATUS )
                        END DO

*                      report error context

                        IF ( STATUS .NE. SAI__OK ) THEN
                           CALL ERR_OUT( 'ERR_FITSIN_WRLOG',
     :                       'FITSIN: Error writing header cards '/
     :                       /'to the file $LOGFILE', STATUS )
                           GOTO 980
                        END IF
                     END IF

*                   Is data conversion a possible requirement?

                     IF ( .NOT. NOCON ) THEN

*                      See if we wish to override the standard data TYPE

                        CALL AIF_GTDLG( 'FMTCNV', .FALSE., FMTCNV,
     :                                  STATUS )
                        CALL PAR_CANCL( 'FMTCNV', STATUS )

                        IF ( STATUS .EQ. PAR__ABORT ) THEN
                           CALL DAT_ANNUL( TLOC, STATUS )
                           GOTO 980
                        END IF
                     END IF

*                   Use BITPIX to determine the data format
*                   Note absolute because BITPIX may soon be negative

                     BPV = ABS( BITPIX / 8 )

                     IF ( BPV .EQ. 1 ) THEN
                        FORMTI = '_CHAR'
                        FORMIN = UBYTE
                     ELSE IF ( BPV .EQ. 2 ) THEN
                        FORMTI = '_WORD'
                        FORMIN = WORD
                     ELSE IF ( BPV .EQ. 4 ) THEN 
                        FORMTI = '_INTEGER'
                        FORMIN = LWORD
                     END IF

                     IF ( FMTCNV ) THEN
                        FORMAT = '_REAL'
                     ELSE
                        FORMAT = FORMTI
                     END IF

                     IF ( AUTO ) THEN

*                      Generate the file name or prefix if a
*                      group-format file

                        CALL CHR_ITOC( FN, FILNO, NCFILN )
                        FILROO = PREFIX( :NCPREF )//FILNO( :NCFILN )

*                      Find the new length of the name string

                        NCROOT = NCPREF + NCFILN
                     END IF

*                   Loop for each data array

                     DO N = 1, GCOUNT

                        ASSOC = N .EQ. 1 .AND. .NOT. AUTO

*                      First time get file by ASSOC, but subsequent
*                      group members have group number appended to
*                      the name so an indirect route is required to
*                      prevent prompting.  The exception is automatic
*                      mode where no prompting is wanted.

                        IF ( ASSOC ) THEN

*                         Create the container file
 
                           CALL DAT_CREAT( 'OUTPUT', 'NDF', 0, 0,
     :                                     STATUS )
                           CALL DAT_ASSOC( 'OUTPUT', 'UPDATE', LOC,
     :                                     STATUS )

*                         Check for option not to create file

                           IF ( STATUS .EQ. PAR__NULL ) THEN
                              CALL ERR_ANNUL( STATUS )
                              CALL MSG_OUT( 'NOOUT',
     :                          'Null parameter -- no output file '/
     :                          /'created', STATUS )

                              CALL DAT_CANCL( 'OUTPUT', STATUS )
                              CALL DAT_ANNUL( TLOC, STATUS )
                              GO TO 960
                           END IF

*                      Groups format

                        ELSE

*                         Generate the new filename, which is either
*                         the root followed by the group suffix for
*                         group-format data (except for the first
*                         group), or...

                           IF ( GCOUNT .GT. 1 ) THEN
                              IF ( N .GT. 1 ) THEN
                                 CALL CHR_ITOC( N, FILNO, NCFILN )
                                 FILNAM = FILROO( :NCROOT )//'G'/
     :                                    /FILNO( :NCFILN )
                              ELSE
                                 FILNAM = FILROO( :NCROOT )
                              END IF

                           ELSE

*                            ... the name generated by the application
*                            in automatic mode and no groups

                              FILNAM = FILROO
                           END IF
 
*                         Create the new file

                           CALL HDS_NEW( FILNAM, 'NDF', 'NDF', 0, 0,
     :                                   LOC, STATUS )

*                      end of first-NDF check

                        END IF


*                      Report errors and abort

                        IF ( STATUS .NE. SAI__OK ) THEN
                           IF ( STATUS .NE. PAR__ABORT ) THEN

                             CALL MSG_SETC ( 'FILNAM', FILNAM )
                             CALL ERR_REP( 'ERR_FITSIN_NOFILE',
     :                          'FITSIN: No file ^FILNAM created.',
     :                          STATUS )
                           END IF

*                         Note file must be closed if obtained via
*                         HDS_NEW

                           IF ( ASSOC ) THEN
                              CALL DAT_ANNUL( LOC, STATUS )
                           ELSE
                              CALL HDS_CLOSE( LOC, STATUS )
                           END IF
                           CALL DAT_ANNUL( TLOC, STATUS )
                           GOTO 980
                        END IF

*                      Create the top-level components
*                      First the VARIANT

                        CALL DAT_NEW0C( LOC, 'VARIANT', 6, STATUS )
                        CALL CMP_PUT0C( LOC, 'VARIANT', 'SIMPLE',
     :                                  STATUS )
                        IF ( STATUS .NE. SAI__OK ) THEN
                           CALL ERR_REP( 'ERR_FITSIN_VAR',
     :                       'FITSIN: Error creating or assigning '/
     :                       /'value to VARIANT', STATUS )

                           CALL DAT_ANNUL( TLOC, STATUS )

*                         Note file must be closed if obtained via
*                         HDS_NEW

                           IF ( ASSOC ) THEN
                              CALL DAT_ANNUL( LOC, STATUS )
                           ELSE
                              CALL HDS_CLOSE( LOC, STATUS )
                           END IF
                           GOTO 980
                        END IF

*                      Now the data array.  Note this is a primitive
*                      at the top-level for the time being so that
*                      old KAPPA may read it.

                        CALL DAT_NEW( LOC, 'DATA_ARRAY', FORMAT,
     :                                NDIM, DIMS, STATUS )
                        IF ( STATUS .NE. SAI__OK ) THEN
                           CALL ERR_REP( 'ERR_FITSIN_CRDAT',
     :                       'FITSIN: Error creating DATA_ARRAY',
     :                       STATUS )

                           CALL DAT_ANNUL( TLOC, STATUS )

*                         Note file must be closed if obtained via
*                         HDS_NEW

                           IF ( ASSOC ) THEN
                              CALL DAT_ANNUL( LOC, STATUS )
                           ELSE
                              CALL HDS_CLOSE( LOC, STATUS )
                           END IF
                           GOTO 980
                        END IF

                        CALL DAT_NEW( LOC, 'MORE', 'EXT', 0, 0, STATUS )

                        IF ( STATUS .NE. SAI__OK ) THEN
                           CALL ERR_REP( 'ERR_FITSIN_CRMORE',
     :                       'FITSIN: Error creating MORE', STATUS )

                           CALL DAT_ANNUL( TLOC, STATUS )
                           IF ( ASSOC ) THEN
                              CALL DAT_ANNUL( LOC, STATUS )
                           ELSE
                              CALL HDS_CLOSE( LOC, STATUS )
                           END IF
                           GOTO 980
                        END IF

*                      Now create .FITS structure

                        CALL DAT_FIND( LOC, 'MORE', MLOC, STATUS )

                        CALL DAT_NEW( MLOC, 'FITS', 'EXT', 0, 0,
     :                                STATUS )

                        IF ( STATUS .NE. SAI__OK ) THEN
                           CALL ERR_REP( 'ERR_FITSIN_CRFITS',
     :                       'FITSIN: Error creating MORE.FITS',
     :                       STATUS )
                           CALL DAT_ANNUL( TLOC, STATUS )
                           CALL DAT_ANNUL( MLOC, STATUS )

*                         Note file must be closed if obtained via
*                         HDS_NEW

                           IF ( ASSOC ) THEN
                              CALL DAT_ANNUL( LOC, STATUS )
                           ELSE
                              CALL HDS_CLOSE( LOC, STATUS )
                           END IF
                           GOTO 980
                        END IF

                        IF ( DARRAY ) THEN

                           IF ( FMTCNV ) THEN

*                            Create a work array for the input data

                              CALL DAT_TEMP( FORMTI, NDIM, DIMS,
     :                                       WKLOC, STATUS )

*                            Map it

                              CALL DAT_MAP( WKLOC, FORMTI, 'WRITE', 
     :                                      NDIM, DIMS, WKPNTR, STATUS )

                              IF ( STATUS .NE. SAI__OK ) THEN

                                 CALL ERR_REP( 'ERR_FITSIN_WSP',
     :                             'FITSIN : Unable to get workspace '/
     :                             /'for data conversion', STATUS )
                                 WKMAP = .FALSE.
                                 GOTO 970
                              END IF

                              WKMAP = .TRUE.

                           END IF


*                         Map the data array

                           CALL CMP_MAPN( LOC, 'DATA_ARRAY', FORMAT,
     :                                    'WRITE', NDIM, DAPNTR, DIMS,
     :                                    STATUS )

*                         Clear up after an error

                           IF ( STATUS .NE. SAI__OK ) THEN
                              CALL ERR_REP( 'ERR_FITSIN_NOMPO',
     :                          'FITSIN: Error in mapping NDF', STATUS )
                              DAMAP = .FALSE.
                              GOTO 970
                           END IF

                           DAMAP = .TRUE.

*                         Select pointer to where the data are to
*                         be stored

                           IF ( FMTCNV ) THEN
                              PNTR = WKPNTR
                           ELSE
                              PNTR = DAPNTR
                           END IF

                           IF ( NONSDA ) THEN

*                            Read the data into the data array, and
*                            read the parameters

                              CALL FITSRG( MT, SIZE, BPV, PCOUNT,
     :                                     BLKSIZ, ACTSIZ, 
     :                                     %REF( BUFFER ), OFFSET,
     :                                     PARAMS, %VAL( PNTR ), 
     :                                     STATUS )

*                            Tidy up after an error

                              IF ( STATUS .NE. SAI__OK ) THEN
                                 CALL DAT_ANNUL( TLOC, STATUS )
                                 CALL DAT_ANNUL( MLOC, STATUS )
                                 CALL CMP_UNMAP( LOC, 'DATA_ARRAY',
     :                                           STATUS )
                                 IF ( ASSOC ) THEN
                                    CALL DAT_ANNUL( LOC, STATUS )
                                 ELSE
                                    CALL HDS_CLOSE( LOC, STATUS )
                                 END IF
                                 IF ( FMTCNV ) THEN
                                    CALL DAT_UNMAP( WKLOC, STATUS )
                                    CALL DAT_ANNUL( WKLOC, STATUS )
                                 END IF
                                 IF ( ASSOC )
     :                             CALL DAT_CANCL( 'OUTPUT', STATUS )
                                 GOTO 960
                              END IF

                              IF ( LOGHDR ) THEN
                                 DUMMY = ' '
                                 CALL FIO_WRITE( FD, DUMMY, STATUS )
                                 WRITE( DUMMY, '(''** File number:'',
     :                                  I6,'';  Group'',I6,
     :                                  '' parameters'')' ) FN, N
                                 CALL FIO_WRITE( FD, DUMMY, STATUS )
                              END IF

*                            Enlarge the structure containing the
*                            FITS header cards

                              CALL DAT_ALTER( TLOC, 1, HDNUM + PCOUNT,
     :                                        STATUS )

                              IF ( STATUS .NE. SAI__OK ) THEN
                                 CALL ERR_REP( 'ERR_FITSIN_ENHEAD',
     :                             'FITSIN: Unable to enlarge header '/
     :                             /'for group parameters', STATUS )
                                 GOTO 970
                              END IF

*                            Move end card to last element of the cell

                              CALL DAT_CELL( TLOC, 1, HDNUM + PCOUNT,
     :                                       HD1LOC, STATUS )
                              CALL DAT_PUT0C( HD1LOC,
     :                                        HEADER( HDNUM ), STATUS )
                              CALL DAT_ANNUL ( HD1LOC, STATUS )

                              DO  I = 1, PCOUNT

*                               Apply scale and offset to get true
*                               parameter value

                                 TPARAM = DBLE( PARAMS( I ) ) *
     :                                    PSCALE( I ) + PZERO( I )
                                 WRITE( PAVAL, '(G20.12)' ) TPARAM

*                               Create the Pseudo-FITS cards for the
*                               parameters

                                 PACARD = ' '
                                 PACARD = PTYPE( I )( :8 )//'= '//PAVAL

*                               Write text to data structure

                                 CALL DAT_CELL( TLOC, 1, HDNUM + I - 1,
     :                                          HD1LOC, STATUS )
                                 CALL DAT_PUT0C( HD1LOC, PACARD,
     :                                           STATUS )
                                 CALL DAT_ANNUL ( HD1LOC, STATUS )

                                 IF ( STATUS .NE. SAI__OK ) THEN
                                    CALL ERR_OUT( 'ERR_FITSIN_EXHDR',
     :                                'FITSIN: Error extending the '/
     :                                /'header structure', STATUS )
                                    GOTO 970
                                 END IF

                                 IF ( LOGHDR ) THEN

*                                  Write remainder of the 'header',
*                                  i.e. the parameters, to the
*                                  logfile if required.  The END card
*                                  is now appended as a terminator.

                                    CALL FIO_WRITE( FD, PACARD, STATUS )
                                 END IF

*                               Report error context

                                 IF ( STATUS .NE. SAI__OK ) THEN
                                    CALL ERR_OUT( 'ERR_FITSIN_WLOGP',
     :                                'FITSIN: Error writing '/
     :                                /'parameter cards to the '/
     :                                /'file $LOGFILE', STATUS )
                                 END IF
                              END DO

                           ELSE

*                            Read the data into the data array

                              CALL FITSRD( MT, SIZE, BPV, BLKSIZ,
     :                                     ACTSIZ, %REF( BUFFER ),
     :                                     OFFSET,
     :                                     %VAL( PNTR ), STATUS )

*                            Tidy up after an error

                              IF ( STATUS .NE. SAI__OK ) THEN
                                 CALL DAT_ANNUL( TLOC, STATUS )
                                 CALL DAT_ANNUL( MLOC, STATUS )
                                 CALL CMP_UNMAP( LOC, 'DATA_ARRAY',
     :                                           STATUS )
                                 IF ( ASSOC ) THEN
                                    CALL DAT_ANNUL( LOC, STATUS )
                                 ELSE
                                    CALL HDS_CLOSE( LOC, STATUS )
                                 END IF
                                 IF ( FMTCNV ) THEN
                                    CALL DAT_UNMAP( WKLOC, STATUS )
                                    CALL DAT_ANNUL( WKLOC, STATUS )
                                 END IF
                                 IF ( ASSOC )
     :                             CALL DAT_CANCL( 'OUTPUT', STATUS )
                                 GOTO 960
                              END IF

                           END IF

                           IF ( FMTCNV ) THEN

*                            Now the work array must be converted
*                            * This will be superseded by a CNV_ 
*                            routine that will also take care of
*                            flagged/magic-value pixels*

                              CALL STL_FMTCON( FORMIN, REAL,
     :                                         %VAL( WKPNTR ),
     :                                         %VAL( DAPNTR ),
     :                                         SIZE, NBAD )

*                            Tidy workspace

                              CALL DAT_UNMAP( WKLOC, STATUS )
                              CALL DAT_ANNUL( WKLOC, STATUS )

*                            Apply scale and zero, and correct
*                            undefined pixels

                              CALL FITSEX( BSCALE, BZERO, BADPIX, BLANK,
     :                                     SIZE, %VAL( DAPNTR ),
     :                                     STATUS )
                           END IF

*                         Unmap the data array ready for next file

                           CALL CMP_UNMAP( LOC, 'DATA_ARRAY', STATUS )
                           DAMAP = .FALSE.

                        END IF

*                      Copy the dummy header to the real one

                        CALL DAT_FIND( MLOC, 'FITS', FLOC, STATUS )
                        CALL DAT_COPY( TLOC, FLOC, 'IN', STATUS )
                        IF ( STATUS .NE. SAI__OK ) THEN
                           CALL ERR_REP( 'ERR_FITSIN_COPHDR',
     :                       'FITSIN: Error copying dummy header',
     :                       STATUS )
                           CALL DAT_ANNUL( FLOC, STATUS )
                           GOTO 970
                        END IF

*                      Annul the locators and close the container file

                        CALL DAT_ANNUL( FLOC, STATUS )
                        IF ( N .EQ. GCOUNT )
     :                    CALL DAT_ANNUL( TLOC, STATUS )
                        CALL DAT_ANNUL( MLOC, STATUS )

*                      Note file must be closed if obtained via HDS_NEW

                        IF ( ASSOC ) THEN
                           CALL DAT_ANNUL( LOC, STATUS )
                        ELSE
                           CALL HDS_CLOSE( LOC, STATUS )
                        END IF

                        IF ( STATUS .NE. SAI__OK ) GOTO 980

*                      Need to find the prefix for NDFs to store group-
*                      format data arrays.  This need only be done once
*                      and not at all if the application is in
*                      automatic mode.

                        IF ( ASSOC .AND. GCOUNT .GT. 1 ) THEN

*                         Get the ADAM internal code that refers to the
*                         piece of parameter space associated with the
*                         parameter OUTPUT, i.e. the parameter to be
*                         used for the sequence of NDFs

                           CALL SUBPAR_FINDPAR( 'OUTPUT', IMCODE,
     :                                          STATUS )

*                         Associate the file name with the ADAM
*                         internal pointer

                           CALL SUBPAR_GETNAME( IMCODE, FILROO, STATUS )

                           IF ( STATUS .NE. SAI__OK ) THEN
                              CALL ERR_OUT( 'ERR_FITSIN_FILROO',
     :                          'FITSIN: Unable to obtain name of '/
     :                          /'root file for series of NDFs to '/
     :                          /'hold group data', STATUS )
                              CALL DAT_CANCL( 'OUTPUT', STATUS )
                              GOTO 960

                           END IF

                           NCROOT = CHR_LEN( FILROO )
                        END IF

*                      Keep the user posted about the current state of
*                      NDFs created

                        CALL MSG_SETI( 'FN', FN )

                        IF ( GCOUNT .GT. 1 ) THEN

*                         First for group-format

                           CALL MSG_SETI( 'N', N )

*                         Filename is found from the parameter if it was
*                         obtained by association

                           IF ( ASSOC ) THEN
                              CALL MSG_OUT( 'INFUSER',
     :                          'Completed processing of tape file '/
     :                          /'^FN group ^N to $OUTPUT', STATUS )
                           ELSE

*                            or from the generated name if there is one

                              CALL MSG_SETC( 'FILNAM', FILNAM )
                              CALL MSG_OUT( 'INFUSER',
     :                          'Completed processing of tape file '/
     :                          /'^FN group ^N to ^FILNAM', STATUS )
                           END IF

*                      Now for the automatic mode, but no groups

                        ELSE IF ( AUTO ) THEN
                           CALL MSG_SETC( 'FILNAM', FILNAM )
                           CALL MSG_OUT( 'INFUSER',
     :                       'Completed processing of tape file ^FN '/
     :                       /'to ^FILNAM', STATUS )

                        ELSE

*                         Finally no-groups and no automatic mode,
*                         therefore get the filename from the parameter

                           CALL MSG_OUT( 'INFUSER',
     :                       'Completed processing of tape file ^FN '/
     :                       /'to $OUTPUT', STATUS )
                        END IF

*                      Cancel parameter association with current NDF

                        IF ( ASSOC )
     :                    CALL DAT_CANCL( 'OUTPUT', STATUS )

*                   End of group-count loop

                     END DO

*                   Go onto next file even if there has been an FITS
*                   problem reading the current file

  960                CONTINUE

*                End of process-each-file loop

                  END DO

*             End of file-specification check

               END IF

*          End of process-each-file-specification loop

            END DO

*       End of valid-number-of-files check

         END IF

*    Ask for any more files

         CALL AIF_GTDLG( 'MORE', .FALSE., MORE, STATUS )
         IF ( STATUS .EQ. PAR__ABORT ) THEN
            GOTO 980
         ELSE IF ( MORE ) THEN
            CALL PAR_CANCL( 'MORE', STATUS )
            CALL PAR_CANCL( 'FILES', STATUS )
         END IF

*    End of more-files loop

      END DO

      GOTO 980

*    Clear up after an abort

 970  CONTINUE
      CALL DAT_ANNUL( TLOC, STATUS )
      CALL DAT_ANNUL( MLOC, STATUS )
      IF ( DAMAP ) CALL CMP_UNMAP( LOC, 'DATA_ARRAY', STATUS )

*    Note file must be closed if obtained via HDS_NEW

      IF ( ASSOC ) THEN
         CALL DAT_ANNUL( LOC, STATUS )
      ELSE
         CALL HDS_CLOSE( LOC, STATUS )
      END IF
      IF ( FMTCNV ) THEN
         IF ( WKMAP ) CALL DAT_UNMAP( WKLOC, STATUS )
         CALL DAT_ANNUL( WKLOC, STATUS )
       END IF

 980  CONTINUE
      CALL MAG_ANNUL( MT, STATUS )

 990  CONTINUE
      IF ( LOGHDR ) CALL FIO_CLOSE( FD, STATUS )

*    Exit

 999  CONTINUE

      END
