	SUBROUTINE CRB_XYCURA
C
C
C
      CHARACTER CVAL*1,TITLE*30,PRBUF*40
      CHARACTER TEXT*72,TCOL*1
      LOGICAL IDENT
C
C OBTAIN INTERACTION LEVEL
C
      ILEVEL=2
      CALL GETPAR('ILEVEL','INTEGER',1,1.0,3.0,.TRUE.,ILEVEL,RVAL,
     +            IERR)
C
C  Get input XYlist mark option
C
    1 KOPT = 1
      CALL GETCMD('MARKER','CROSS,ATICK,SPOT,HELP,?.',.TRUE.,KOPT,
     +            TEXT,KTEXT,ISTAT)
      IF (KOPT.EQ.4.OR.KOPT.EQ.5) THEN
         CALL WRUSER('Input XYlist mark types',ISTAT)
         CALL WRUSER('Choices are :-',ISTAT)
         CALL WRUSER('CROSS    Cross',ISTAT)
         CALL WRUSER('ATICK    Ticks at (-2:0) and (2:0)'//
     +               ' alternately',ISTAT)
         CALL WRUSER('SPOT     1 pixel spots',ISTAT)
         CALL CNPAR('MARKER',ISTAT)
         GO TO 1
      ENDIF
C
C  Get colour of input spots
C
    2 KCOL = 1
      CALL GETCMD('COLOUR','B,W,R,Y,C,M,G,HELP,?.',.TRUE.,KCOL,
     +            TEXT,KTEXT,ISTAT)
      IF (KCOL.EQ.8.OR.KCOL.EQ.9) THEN
         CALL WRUSER('Colour to paint input list markers',ISTAT)
         CALL WRUSER('Choices are :-',ISTAT)
         CALL WRUSER('White,Red,Blue,Yellow,Cyan,Magenta,Green',
     +               ISTAT)
         CALL WRUSER('(type only the first letter',ISTAT)
         CALL CNPAR('COLOUR',ISTAT)
         GO TO 2
      ENDIF
      IF (KCOL.EQ.1) TCOL = 'B'
      IF (KCOL.EQ.2) TCOL = 'W'
      IF (KCOL.EQ.3) TCOL = 'R'
      IF (KCOL.EQ.4) TCOL = 'Y'
      IF (KCOL.EQ.5) TCOL = 'C'
      IF (KCOL.EQ.6) TCOL = 'M'
      IF (KCOL.EQ.7) TCOL = 'G'
C
C  Get wether to clear all overlay planes before writing
C
    3 KOVCL = 2
      CALL GETCMD('OVERCL','YES,NO,HELP,?.',.TRUE.,KOVCL,
     +            TEXT,KTEXT,ISTAT)
      IF (KOVCL.EQ.3.OR.KOVCL.EQ.4) THEN
         CALL WRUSER('Choices are :-',ISTAT)
         CALL WRUSER('YES      Clear overlay planes',ISTAT)
         CALL WRUSER('NO       Leave planes as they are',ISTAT)
         CALL CNPAR('OVERCL',ISTAT)
         GO TO 3
      ENDIF
C
C OBTAIN AN OPTIONAL INPUT DATA FRAME
C
      CALL GTXYLR('INPUT',.TRUE.,NITEM,LSTLEN,IPIN,IERRI)
C
C IF INPUT NOT OBTAINED, SET DEFAULT VALUES FOR THE LIST DIMENSIONS
C NITEM=NO OF 4-BYTE ITEMS PER LIST RECORD
C LSTLEN=NO OF LIST RECORDS
C
      IF(IERRI.NE.0) THEN
         NITEM=7
         LSTLEN=0
      ENDIF
C
C SET DEFAULT FOR MAX LENGTH OF OUTPUT LIST, THEN OBTAIN VALUE FROM
C ENVIRONMENT
C
      LENOUT=LSTLEN+2000
      CALL GETPAR('MAXENTRY','INTEGER',1,REAL(LSTLEN+1),1.0E6,.TRUE.,
     +LENOUT,RVAL,IERR)
C
C OBTAIN VIRTUAL MEMORY WORKSPACE TO HOLD IDENTIFIERS AND X,Y
C VALUES
C
      CALL GETDYN('ID',104,5*LENOUT,IPID,ISTATI)
      CALL GETDYN('X',104,LENOUT,IPX,ISTATX)
      CALL GETDYN('Y',104,LENOUT,IPY,ISTATY)
C
C IF SPACE NOT AVAILABLE... GIVE ERROR MESSAGE AND ABORT
C
      IF((ISTATI.NE.0).OR.(ISTATX.NE.0).OR.(ISTATY.NE.0)) THEN
	CALL WRERR('NOSPACE')
        GO TO 99
      ENDIF
C
C IF INPUT WAS SUPPLIED, COPY INPUT LIST DATA TO WORKSPACE
C
      IF(IERRI.EQ.0) THEN
	CALL EXTLST(%VAL(IPIN),NITEM,LSTLEN,%VAL(IPID),1,20)
	CALL EXTLST(%VAL(IPIN),NITEM,LSTLEN,%VAL(IPX),21,24)
	CALL EXTLST(%VAL(IPIN),NITEM,LSTLEN,%VAL(IPY),25,28)
      ENDIF
C
C DETERMINE IF IDENTIFIERS ARE TO BE PROMPTED FOR
C
      IDENT=.FALSE.
      CALL RDKEYL('IDENTIFY',.TRUE.,1,IDENT,NVAL,ISTAT)
C
C DETERMINE IF INPUT LIST CROSSES TO BE PUT UP
C
      IF(IERRI.EQ.0) THEN
         CALL WRUSER('DISPLAY INPUT LIST POSITIONS ?',JSTAT)
    4    KFXOUT = 1
         CALL GETCMD('FXOUT','YES,NO,HELP,?.',.TRUE.,KFXOUT,
     +               TEXT,KTEXT,ISTAT)
         IF (KFXOUT.EQ.3.OR.KFXOUT.EQ.4) THEN
            CALL WRUSER('Choices are :-',ISTAT)
            CALL WRUSER('YES     Positions are displayed',ISTAT)
            CALL WRUSER('NO      Positions not displayed',ISTAT)
            CALL CNPAR('FXOUT',ISTAT)
            GO TO 4
         ENDIF
         IF (KFXOUT.EQ.1) THEN
            CALL WRUSER('NUMBER THEM ?',ISTAT)
            NUMINP = 2
            CALL GETCMD('NUMINP','NO,YES.',1,NUMINP,PRBUF,NVAL,
     +                  ISTAT)
         ENDIF
      ENDIF
C
C  Initialise the ARGS and get compression and window data
C
      ISTAT=0
      CALL SRINIT(0,.FALSE.,ISTAT)
      IF (ISTAT.NE.0) THEN
         CALL WRERR('NOARGS')
         GO TO 99
      ELSE
         CALL ARGS_NUMIM(ID)
         CALL ARGS_RDIM(IXPOS,IYPOS,ISX,ISY,I,I,ISTAT)
         CALL ARGS_RDPAR('COMPRE',1,TEXT,NVALS,ISTAT)
         IF (ISTAT.EQ.0) THEN
            READ(TEXT,900)KXB,KXE,KYB,KYE,KCOMP
  900       FORMAT(5I10)
            COMFAC = REAL(KCOMP)
            DX = REAL(KXB)
            DY = REAL(KYB)
         ELSE
            COMFAC = 1.0
            DX = 1.0
            DY = 1.0
         ENDIF
      ENDIF
C
C  Do the input list (if any) display and get the new positions
C
      LENBEG = LSTLEN
      CALL XYINCA(%VAL(IPID),%VAL(IPX),%VAL(IPY),LENOUT,LSTLEN,
     +IDENT,ILEVEL,IERR,KOVCL,KFXOUT,NUMINP,COMFAC,DX,DY,ISX,ISY,
     +            KOPT,TCOL)
C
C IF NO LIST OBTAINED, GIVE ERROR MESSAGE, OTHERWISE
C OBTAIN OUTPUT DATA FRAME
C
      IF(LSTLEN.LE.0.OR.LSTLEN.EQ.LENBEG) THEN
        CALL WRERR('NOLIST')
      ELSE
	CALL GTXYLW('OUTPUT',.FALSE.,7,LSTLEN,IPOUT,IERR2)
	IF(IERR2.EQ.0) THEN
C
C OUTPUT FRAME SUCCESSFULLY OBTAINED. COPY LISTS FROM WORKSPACE TO
C OUTPUT DATA FRAME
C
          CALL ADDLST(%VAL(IPOUT),7,LSTLEN,%VAL(IPID),1,20)
	  CALL ADDLST(%VAL(IPOUT),7,LSTLEN,%VAL(IPX),21,24)
	  CALL ADDLST(%VAL(IPOUT),7,LSTLEN,%VAL(IPY),25,28)
C
C TELL USER HOW MANY ENTRIES IN OUTPUT LIST
C
	  IF(ILEVEL.GE.2) THEN
            WRITE(PRBUF,104)LSTLEN
	    IF(LSTLEN.EQ.1) PRBUF(28:)='ENTRY'
  104       FORMAT('   OUTPUT LIST HAS ',I7,' ENTRIES')
            CALL LBGONE(PRBUF(20:))
	    CALL WRUSER(' ',ISTAT)
            CALL WRUSER(PRBUF,ISTAT)
	    CALL WRUSER(' ',ISTAT)
	  ENDIF
C
C DEFAULT OUTPUT TITLE IS EITHER THE INPUT TITLE, OR BLANK.
C THEN OBTAIN A NEW ONE FROM THE ENVIRONMENT
C
	  TITLE='Output from XYCURA'
	  IF(IERRI.EQ.0) THEN
	     CALL GTDSCR('INPUT','TITLE','CHARACTER',IVAL,RVAL,
     +                 TITLE,IERR)
        ENDIF
        CALL RDKEYC('TITLE',.TRUE.,1,TITLE,NVAL,ISTAT)
C
C COPY INPUT DESCRIPTOR TO OUTPUT (IF AVAILABLE) THEN UPDATE
C DESCRIPTOR ITEMS
C
	  IF(IERRI.EQ.0) CALL CYDSCR('INPUT','OUTPUT',ISTAT)
	  CALL PTDSCR('OUTPUT','NITEM','INTEGER',7,RVAL,CVAL,IERR)
	  CALL PTDSCR('OUTPUT','LSTLEN','INTEGER',LSTLEN,RVAL,CVAL,
     +    IERR)
	  CALL PTDSCR('OUTPUT','TITLE','CHARACTER',IVAL,RVAL,TITLE,
     +	  IERR)
	ENDIF
      ENDIF
C
C REPOSITION IMAGE AT CENTRE OF ARGS
C
      CALL ARCEMA(255,255,1,1,1)
C
C FREE ALL DATA AREAS AND EXIT
C
   99 CALL FRDATA(' ',ISTAT)
C
C
C
	CALL CNPAR('OVERCL',JSTAT)
	CALL CNPAR('OUTPUT',JSTAT)
	CALL CNPAR('INPUT',JSTAT)
      END
 
 
 
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      **************
C      *            *
C      * S/R XYINCA *
C      *            *
C      **************
C
C
* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*	TO INTERACTIVELY OBTAIN A SET OF X,Y POSITIONS AND ATTACHED
*	CHARACTER IDENTIFIERS FROM THE ARGS AND INSERT THEM IN
*	A LIST OF POSITIONS
*     ALSO, IF REQUIRED, TO PUT UP AS CROSSES ANY POSITIONS ALREADY
*     IN THE LIST
*
*METHOD
*       IF WANTED, GET ALL POSNS FROM INPUT LIST AND PUT ON ARGS
*       SCREEN USING S/R CROSS TAKEN FROM PRGM SLICE
*       OBTAIN X,Y POSITION FROM THE ARGS SCREEN USING ASP_PAN AND
*       IDENTIFIER (IF REQUIRED) FROM KEYBOARD USING STARLINK
*	PARAMETER 'IDENTITY'.
*	IF THE IDENTIFIER IS BLANK, CREATE ONE USING THE CURRENT
*	COUNT OF BLANK IDENTIFIERS ENTERED. IF THE IDENTIFIER IS IN THE
*	FORM #N, RESET THE BLANK COUNTER TO N. OTHERWISE USE THE
*	IDENTIFIER AS IT STANDS AND ADD IT TO THE LIST.
*
*ARGUMENTS
*	ID (IN/OUT)
*	BYTE(20,MAXLEN)
*		A LIST OF 20 BYTE ASCII IDENTIFIERS
*	X,Y (IN/OUT)
*	REAL(MAXLEN)
*		LISTS OF X,Y POSITIONS
*	MAXLEN (IN)
*	INTEGER
*		THE MAXIMUM NUMBER OF ENTRIES WHICH CAN BE HELD IN THE
*		LISTS
*	LEN (IN/OUT)
*	INTEGER
*		ON ENTRY, GIVES THE NUMBER OF ENTRIES ALREADY IN THE
*		LISTS ID,X AND Y. ON EXIT, GIVES THE NUMBER OF ENTRIES
*		IN THE OUTPUT LISTS.
*       IDENT (IN)
*       LOGICAL
*               IF TRUE, IDENTIFIERS ARE PROMPTED FOR
*       ILEVEL (IN)
*       INTEGER
*               INTERACTION LEVEL: CONTROLS PRINTING OF POSITIONS ON
*               SCREEN AS THEY ARE OBTAINED
*	IERR (OUT)
*	INTEGER
*		ERROR FLAG: ZERO FOR SUCCESS
*		1: LEN .GT. MAXLEN ON ENTRY
*
*     KOVCL (IN)
*     INTEGER
*             FLAG FOR CLEARING OVERLAY PLANE ON ENTRY
*     KFXOUT (IN)
*     INTEGER
*             FLAG FOR PUTTING UP CROSSES FROM INPUT LIST (1=YES)
*     NUMINP
*     INTEGER
*             FLAG FOR NUMBERING INPUT LIST CROSSES (1=NO)
*     COMFAC (IN)
*     REAL
*             COMPRESSION FACTOR OF DISPLAY
*     DX     (IN)
*     REAL
*             DISPLAY X START COORDINATE
*     DY     (IN)
*     REAL
*             DISPLAY Y START COORDINATE
*
*    Input
*     ISX     Int       X width of display
*     ISY     Int       Y width of display
C     KOPT    Int       flag for XYlist input mark type 1=+,2=tick,3=spo
*     TCOL    Char*1    Colour to paint input markers
*
*STARLINK PARAMETERS
*       IDENTITY
*               CHARACTER IDENTIFIER FOR POSITIONS
*
*CALLS
*	EDRS PACKAGE:
*		LBGONE,GETCMD
*	STARLINK:
*		RDKEYC,CNPAR,CTOR,WRERR,CTOI
*     ASPIC:
*             ASP_PAN,ARGS_CLS,ARGS_NUMIM,ARGS_OVCL
*     THIS FILE:
*             CROSS,ATICK,SPOT,ARGS_OVOPN
*
*NOTES
*	USES BYTE ARRAYS
*
*WRITTEN BY
*	R.F. WARREN-SMITH
*ADAPTED BY
*     A.J. PENNY
* ----------------------------------------------------------------------
C
C
C
